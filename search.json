[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Combinatorics Notes",
    "section": "",
    "text": "Preface\nCombinatorics notes extending the book Applied Combinatorics by Keller and Trotter.\n\nThis work © 2024 by Trevor Gunn is licensed under CC BY-SA 4.0",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "inclusion-exclusion.html",
    "href": "inclusion-exclusion.html",
    "title": "1  Inclusion/Exclusion",
    "section": "",
    "text": "1.1 For two sets\nGiven two sets \\(A\\) and \\(B\\), we can compute \\(|A \\cup B|\\) by first adding everything in \\(A\\) and adding everything in \\(B\\). This counts all of \\(A \\cup B\\) except the items in \\(A \\cap B\\) were counted twice. Thus\n\\[\n|A| + |B| = |A \\cup B| + |A \\cap B|.\n\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion.html#for-two-sets",
    "href": "inclusion-exclusion.html#for-two-sets",
    "title": "1  Inclusion/Exclusion",
    "section": "",
    "text": "Example 1.1 Suppose there are \\(100\\) CS students an a school. Of these, \\(50\\) know Java and \\(60\\) know Python (everyone knows at least one of these two languages). If we add \\(50 + 60\\) we get the \\(100\\) total students plus \\(10\\) students who know both.\n\\[\n50 + 60 = 100 + 10.\n\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion.html#for-three-sets",
    "href": "inclusion-exclusion.html#for-three-sets",
    "title": "1  Inclusion/Exclusion",
    "section": "1.2 For three sets",
    "text": "1.2 For three sets\n\n\n\nInclusion/Exclusion for 3 sets\n\n\nWe can do a similar process for three sets. Start by adding up \\(|A| + |B| + |C|\\) then subtract all the intersections of pairs then add back in \\(|A \\cap B \\cap C|\\). For items in each region of the Venn diagram, think about how many times an item is added/subtracted overall.\nE.g. items in \\(A\\) and \\(B\\) but not \\(C\\) will be added in twice in the first step (\\(|A| + |B|\\)) and subtracted once in the second step (\\(|A \\cap B|\\)) so they are counted once.\nItems in \\(A \\cap B \\cap C\\) are added in \\(3 - 3 + 1 = 1\\) times.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion.html#sec-binomials-and-IE",
    "href": "inclusion-exclusion.html#sec-binomials-and-IE",
    "title": "1  Inclusion/Exclusion",
    "section": "1.3 Binomial coefficients and I/E",
    "text": "1.3 Binomial coefficients and I/E\nSuppose we are looking at a union of \\(n\\) sets: \\(A_1 \\cup \\dots \\cup A_n\\). Consider an element \\(x\\) belonging exactly to \\(A_1, \\dots, A_m\\) and no other sets. If we do the same procedure of adding \\(|A_1| + \\dots + |A_n|\\) then we are counting \\(x\\) a total of \\(m\\) times. Then, when we subtract all the pairwise intersections, \\(|A_i \\cap A_j|\\), we are subtracting from the count of \\(x\\) a total of \\(\\binom{m}{2}\\) because there are \\(\\binom{m}{2}\\) ways to choose two indices \\(\\{i, j\\} \\subset \\{1, \\dots, m\\}\\).\nThus, if we alternate: adding in single sets, subtracting pairs of intersections, adding tripples, subtracting quadruples, etc. we are counting \\(x\\) a total of\n\\[\n\\binom{m}1 - \\binom{m}2 + \\binom{m}3 -  \\binom{m}4 + \\cdots\n\\tag{1.1}\\] times.\nLet’s have a closer look at this. We know the Binomial Theorem says that \\[\n(1 + x)^m = \\binom{m}0x^0 + \\binom{m}1x^1 + \\binom{m}2x^2 + \\dots + \\binom{m}mx^m.\n\\] Substituting \\(x = -1\\), we get\n\\[\n0 = \\binom{m}0 - \\binom{m}1 + \\binom{m}2 - \\dots + \\binom{m}m (-1)^m.\n\\]\nAnd since \\(\\binom{m}0 = 1\\), if we move all the other terms to the other side of the equation, we see that Equation 1.1 evaluates to \\(1\\).\n\n\n\n\n\n\nNote 1.1\n\n\n\nFor this problem we are counting the size of \\(A_1 \\cup \\dots \\cup A_n\\) so each element is in at least one set (\\(m \\ge 1\\)). This is important so that we can say that \\(0^m = 0\\). In the context of the binomial theorem, \\((1 - 1)^0 = \\binom{0}{0} = 1\\). This will be important later when we want to count elements not belonging to any set.\n\n\nThe general I/E formula is then\n\\[\\begin{align*}\n|A_1 \\cup \\dots \\cup A_n| &= \\sum_i |A_i| - \\sum_{i &lt; j} |A_i \\cap A_j| + \\sum_{i &lt; j &lt; k} |A_i \\cap A_j \\cap A_k| - \\dots \\\\\n&= \\sum_{t = 1}^n (-1)^{t + 1} \\sum_{i_1 &lt; \\dots &lt; i_t} |A_{i_1} \\cap \\dots \\cap A_{i_t}|.\n\\end{align*}\\]\nNote: \\((-1)^{t + 1}\\) takes the values \\(1, -1, 1, -1, \\dots\\) starting at \\(t = 1\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion.html#sec-avoiding",
    "href": "inclusion-exclusion.html#sec-avoiding",
    "title": "1  Inclusion/Exclusion",
    "section": "1.4 Avoiding properties",
    "text": "1.4 Avoiding properties\nInclusion/Exclusion appears most frequently in combinatorics not as a means to count \\(|A_1 \\cup \\dots \\cup A_n|\\) directly but rather as a means to count everything not in \\(A_1 \\cup \\dots \\cup A_n\\).\nFor example, let $[m] = {1,,m} and suppose we want to count the number of functions \\(f : [m] \\to [n]\\) which don’t miss anything in the codomain. I.e. if \\(A_i\\) is the set of functions where \\(f(x)\\) never equals \\(i\\), then we want to count every function not in any set \\(A_i\\).\nLet \\(X\\) be the total set of functions. Then to count the functions avoiding \\(A_1 \\cup \\dots \\cup A_n\\) we do\n\\[\\begin{align*}\n|X \\setminus (A_1 \\cup \\dots A_n)| &= |X| - |A_1 \\cup \\dots A_n| \\\\\n&= |X| - \\sum_i |A_i| + \\sum_{i &lt; j} |A_i \\cap A_j| - \\cdots\n\\end{align*}\\]\n\n\n\n\n\n\nCaution\n\n\n\nThe formula \\(|A \\setminus B| = |A| - |B|\\) works only when \\(B\\) is contained entirely inside \\(A\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion.html#simplifying-notation.",
    "href": "inclusion-exclusion.html#simplifying-notation.",
    "title": "1  Inclusion/Exclusion",
    "section": "1.5 Simplifying notation.",
    "text": "1.5 Simplifying notation.\nLet \\(\\mathscr{P} = \\{P_1, \\dots, P_n\\}\\) be a collection of sets representing negative properties—conditions we want to avoid. For a subset \\(S \\subseteq \\{1,\\dots,n\\}\\), let \\(N_\\ge(S)\\) be the number of items satisfying at least those properties in \\(S\\). I.e. \\(\\bigcap_{i \\in S} P_i\\). We will say “\\(x\\) satisfies \\(S\\)” for short. Also, if \\(S = \\{a,b,c\\}\\), let us write for example, \\(N_\\ge(a,b,c)\\) instead of \\(N_\\ge(\\{a,b,c\\})\\) for simplicity.\nLet \\(N_{=}(S)\\) be the number of \\(x\\) satisfying exactly those properties in \\(S\\) and no properties not in \\(S\\). When \\(\\mathscr{P}\\) represents properties we wish to avoid, then \\(N_{=}(\\varnothing)\\) is the number of elements satisfying none of the properties.\n\nTheorem 1.1 (Inclusion/Exclusion) \\[\\begin{align*}\nN_{=}(\\varnothing) &= N_{\\ge}(\\varnothing) - \\sum_i N_\\ge(i) + \\sum_{i &lt; j} N_\\ge(i,j) - \\cdots \\\\\n&= \\sum_{S} (-1)^{|S|} N_\\ge(S).\n\\end{align*}\\]\n\n\nProof. As in Section 1.3, we will break up the sum focusing on each element. So first, we will write \\[\n\\sum_{S} (-1)^{|S|} N_\\ge(S) = \\sum_S (-1)^{|S|} \\sum_{\\substack{x \\\\ x \\text{ satisfies } S}} 1\n\\]\nHere we replace the number \\(N_\\ge(S)\\) by a count of \\(1\\) for each element \\(x\\) which satisfies \\(S\\). This introduces a second sum into the picture and that will allow us to swap the order of summations. Currently, the second sum is over all \\(x\\) with respect to the relation “\\(x\\) satisfies \\(S\\).” When we put the sum over \\(x\\) outside, we still have the relation “\\(x\\) satisfies \\(S\\)” but rather than summing over all \\(x\\) with this property, we sum over all \\(S\\):\n\\[\n\\sum_S (-1)^{|S|} \\sum_{\\substack{x \\\\ x \\text{ satisfies } S}} 1 = \\sum_x \\sum_{\\substack{S \\\\ x \\text{ satisfies } S}} (-1)^{|S|}.\n\\]\nWe also move the \\((-1)^|S|\\) inside the second sum because that quantity depends on \\(|S|\\).\nNext, just as we did in Section 1.3, let us say that \\(x\\) satisfies exactly \\(P_{i_1}, \\dots, P_{i_m}\\) (\\(m\\) will depend on \\(x\\)) and let \\(S_x = \\{i_1, \\dots, i_m\\}\\). This set is the largest set that \\(x\\) satisfies. Every other set that \\(x\\) satisfies will be a subset of \\(S_x\\).\nWe now break up our sum based on the size of those subsets \\(S \\subseteq S_x\\), using the binomial coefficients to count the number of such \\(S\\):\n\\[\n\\sum_x \\sum_{\\substack{S \\\\ x \\text{ satisfies } S}} (-1)^{|S|} = \\sum_x \\sum_{k = 0}^m \\underbrace{\\binom{m}{k} (-1)^k}_{\\substack{|S| = k \\text{ and } x \\text{ satisfies } S \\\\ \\iff |S| = k \\text{ and } S \\subseteq S_x}}.\n\\]\nThis, by the Binomial Theorem, is the same as \\[\n\\sum_x (1 - 1)^m.\n\\] Remember here that \\(m\\) depends on \\(x\\).\nAs discussed in Note 1.1, \\(0^m = 0\\) if \\(m \\ge 1\\) but if \\(m = 0\\) then \\(0^0 = 1\\). Saying \\(m = 0\\) means that \\(x\\) satisfies exactly \\(0\\) properties—which is what we are looking for. So the final simplification looks like \\[\n\\sum_x 0^m = \\sum_{\\substack{x \\\\ m = 0}} 1 = N_{=}(\\varnothing).\n\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion.html#application-1-surjections",
    "href": "inclusion-exclusion.html#application-1-surjections",
    "title": "1  Inclusion/Exclusion",
    "section": "1.6 Application 1: Surjections",
    "text": "1.6 Application 1: Surjections\nAs in Section 1.4, let \\(X\\) be the set of all functions from \\([m]\\) to \\([n]\\) and let \\(P_i\\) be the set of functions where \\(i\\) is never an output: \\(f(x) \\neq i\\) for any input \\(x\\).\n\nLemma 1.1  \n\nThe number of functions from an \\(m\\) element set to an \\(n\\) element set is \\(n^m\\).\nThe number of functions from an \\(m\\) element set to an \\(n\\) element set that avoid \\(k\\) outputs is \\((n - k)^m\\).\n\n\n\nProof. \n\nThere are \\(n\\) choices for \\(f(1)\\) and \\(n\\) choices for \\(f(2)\\), etc. So there are \\(n^m\\) choices in total for \\(f(1), \\dots, f(m)\\).\nIf we are avoiding \\(k\\) outputs then there are only \\(n - k\\) choices for each of \\(f(1),\\dots,f(m)\\) so \\((n - k)^m\\).\n\n\nWith this in mind, we have \\(N_\\ge(S) = (n - k)^m\\) if \\(|S| = k\\) (we avoid at least the specified \\(k\\) outputs). So by inclusion exclusion, the number of functions which avoid no outputs (i.e. surjections) is\n\\[\\begin{align*}\n&N_\\ge(\\varnothing) - \\sum_i N_\\ge(i) + \\sum_{i &lt; j} N_\\ge(i,j) - \\cdots \\\\\n&\\hspace{4em} = n^m - \\sum_i (n - 1)^m + \\sum_{i &lt; j} (n - 2)^m - \\cdots.\n\\end{align*}\\]\nAnd since there are \\(\\binom{n}{k}\\) ways to choose \\(k\\) outputs to avoid, we can also write this as\n\\[\nn^m - \\binom{n}1 (n - 1)^m + \\binom{n}2 (n - 2)^m - \\dots = \\sum_{k} \\binom{n}k (-1)^k (n - k)^m.\n\\]\nThe textbook calls this number \\(S(m,n)\\).\n\n\n\n\n\n\nNote\n\n\n\nIn the above application, \\(N_\\ge(S) = (n - k)^m\\) only depended on the size \\(k\\) of \\(S\\). This is true in many but not all examples.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion.html#application-2-derangements",
    "href": "inclusion-exclusion.html#application-2-derangements",
    "title": "1  Inclusion/Exclusion",
    "section": "1.7 Application 2: Derangements",
    "text": "1.7 Application 2: Derangements\nLet \\(X\\) be the set of all permutations of \\([n]\\). We wish to count the permutations with no fixed points. So let \\(P_i\\) be the property that \\(i\\) is a fixed point. Then \\(N_{=}(\\varnothing)\\) is the number of permutations with zero fixed points. This number is called \\(d_n\\) in the textbook.\n\nLemma 1.2  \n\nThe number of permutations of \\([n]\\) is \\(n!\\)\nThe number of permutations with at least \\(k\\) specified fixed points is \\((n - k)!\\)\n\n\n\nProof. \n\nDiscussed in Chapter 2 of the book.\nTo say that there are \\(k\\) specified fixed points means were are permuting the other \\(n - k\\) items. Similar to (a), there are \\((n - k)!\\) ways to permute \\(n - k\\) items.\n\n\nApplying Inclusion/Exclusion, we thus have \\[\nd_n = n! - \\binom{n}1 (n - 1)! + \\binom{n}2 (n - 2)! - \\dots = \\sum_{k} \\binom{n}k (-1)^k (n - k)!.\n\\] Again, there are \\(\\binom{n}k\\) ways to choose a set \\(S\\) of \\(k\\) fixed points and each of these has the same number \\(N_\\ge(S) = (n - k)!\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "permutations.html",
    "href": "permutations.html",
    "title": "2  Permutations",
    "section": "",
    "text": "2.1 As a shuffle of the symbols\nE.g. \\(53214\\) is a shuffle of \\(X = \\{1,2,3,4,5\\}\\).\nThis gives us one way of counting the number of permutations. For the first position in the shuffle, we may write any of the \\(n\\) numbers. For the second position, we have \\(n - 1\\) numbers to choose from—we cannot repeat the first. Likewise the third has \\(n - 2\\) to choose from, not repeating the first or second. In this way, the number of permutations is\n\\[\nn \\cdot (n - 1) \\cdot (n - 2) \\cdots 2 \\cdot 1, \\text{ denoted } n!.\n\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Permutations</span>"
    ]
  },
  {
    "objectID": "permutations.html#sec-function",
    "href": "permutations.html#sec-function",
    "title": "2  Permutations",
    "section": "2.2 As a function from \\(X\\) to itself",
    "text": "2.2 As a function from \\(X\\) to itself\nE.g. The shuffle \\(53214\\) may be thought of as a function \\(\\pi : X \\to X\\) where \\(\\pi(i)\\) equals the \\(i\\)-th number in the shuffle:\n\\[\n\\pi(1) = 5, \\pi(2) = 3, \\pi(3) = 2, \\pi(4) = 1, \\pi(5) = 4.\n\\]\nThese functions are often represented by a table:\n\n\n\n\\(i\\)\n1\n2\n3\n4\n5\n\n\n\n\n\\(\\pi(i)\\)\n5\n3\n2\n1\n4\n\n\n\nSomething new added by the table/function representation is that we can talk about the inverse function which undoes the shuffle:\n\n\n\n\\(j = \\pi(i)\\)\n5\n3\n2\n1\n4\n\n\n\n\n\\(i = \\pi^{-1}(j)\\)\n1\n2\n3\n4\n5\n\n\n\nor reordering the columns:\n\n\n\n\\(j\\)\n1\n2\n3\n4\n5\n\n\n\n\n\\(\\pi^{-1}(j)\\)\n4\n3\n2\n5\n1\n\n\n\n\n2.2.1 Composition of functions\nGiven two permutations, \\(\\pi_1, \\pi_2 : X \\to X\\), we can compose them to get a new function \\((\\pi_1 \\circ \\pi_2)\\). One way to compute this is via the following procedure:\n\nWrite the two functions as tables.\nReorder the columns of the outermost function in the composition to align with the output of the innermost function.\nStack the tables on top of eachother.\n\nE.g. Take \\(\\pi_2\\) to be the function represented by the shuffle \\(53214\\) and take \\(\\pi_1\\) to be represented by the shuffle \\(13254\\). So as a table\n\n\n\n\\(i\\)\n1\n2\n3\n4\n5\n\n\n\n\n\\(\\pi_1(i)\\)\n1\n3\n2\n5\n4\n\n\n\nNow we shuffle the columns so the top is \\(53214\\):\n\n\n\n\\(i\\)\n5\n3\n2\n1\n4\n\n\n\n\n\\(\\pi_1(i)\\)\n4\n2\n3\n1\n5\n\n\n\nThen stack this with \\(\\pi_2\\):\n\n\n\n\\(i\\)\n1\n2\n3\n4\n5\n\n\n\n\n\\(j = \\pi_2(i)\\)\n5\n3\n2\n1\n4\n\n\n\\(\\pi_1(j)\\)\n4\n2\n3\n1\n5\n\n\n\nThe bottom row is \\(\\pi_1 \\circ \\pi_2\\).\n\nExercise 2.1 Compute this in the other order: \\(\\pi_2 \\circ \\pi_1\\). Observe that the order matters.\nNote: in some sources (e.g. books, software), compositions are witten as a product in the reverse order. Here are computation in the software SageMath.\n\nπ1 = Permutation([1,3,2,5,4])\nπ2 = Permutation([5,3,2,1,4])\nπ2 * π1\n\n[4, 2, 3, 1, 5]\n\n\n\nπ1 * π2\n\n[5, 2, 3, 4, 1]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Permutations</span>"
    ]
  },
  {
    "objectID": "visual.html",
    "href": "visual.html",
    "title": "3  Visual representations of permutations",
    "section": "",
    "text": "3.1 As a collection of cycles\nLet’s look at a longer permutation now: \\(541237896\\). As in Section 2.2, we can view this as a function where \\(1\\) goes to \\(5\\), \\(2\\) goes to \\(4\\) etc. Following the path of a single number we get a cycle: \\(1\\) goes to \\(5\\) goes to \\(3\\) goes to \\(1\\). Likewise \\(2\\) goes to \\(4\\) goes to \\(2\\). And so on.\nThe entire permutation can be broken up into cycles:\nπ = Permutation([5,4,1,2,3,7,8,9,6])\nπ.to_digraph().plot(vertex_size=1500)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Visual representations of permutations</span>"
    ]
  },
  {
    "objectID": "visual.html#as-a-collection-of-cycles",
    "href": "visual.html#as-a-collection-of-cycles",
    "title": "3  Visual representations of permutations",
    "section": "",
    "text": "3.1.1 Notation\nThe cycle \\(1 \\to 5 \\to 3 \\to 1\\) can be written as \\((153)\\). In general, \\((a_1,\\dots,a_n)\\) represents the cycle \\(a_1 \\to a_2 \\to \\dots \\to a_n \\to a_1\\). We often ommit the commas when every number is a single digit.\nHere is how to compute the cycles in SageMath:\n\nπ.cycle_string()\n\n'(1,5,3)(2,4)(6,7,8,9)'\n\n\nThe answer is given as a product (i.e. composition) of cycles.\nElements which do not go anywhere—also called fixed-points—are represented by cycles of length \\(1\\) E.g. \\((123)(4)\\) represents the two cycles \\(1 \\to 2 \\to 3 \\to 1\\) and \\(4 \\to 4\\). We often ommit length \\(1\\) cycles from the notation so \\((123)(4) = (123)\\) as a permutation of \\(1,2,3,4\\).\n\nExercise 3.1 Compute the cycle decomposition for \\(341859672\\). You can verify your answer in SageMath.\nπ = Permutation([3,4,1,8,5,9,6,7,2])\nπ.cycle_string()\n\nNote: as mentioned earlier: SageMath ommits the cycle \\((5)\\) representing the fixed point \\(\\pi(5) = 5\\).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Visual representations of permutations</span>"
    ]
  },
  {
    "objectID": "visual.html#sec-braids",
    "href": "visual.html#sec-braids",
    "title": "3  Visual representations of permutations",
    "section": "3.2 Braids",
    "text": "3.2 Braids\nAnother visual representation used frequently in the mathematical study of knots is that of crossing lines. Let’s look at an example:\n\nB.&lt;a,b&gt; = BraidGroup(3)\nplot(a * b * a)\n\n\n\n\n\n\n\n\nThis represents a permutation where the first end ends up in the third position (\\(1 \\to 3\\)), the second end ends up in the second position (\\(2 \\to 2\\)) and the third end ends up in the first position (\\(3 \\to 1\\)). Overall, \\(1\\) and \\(3\\) are swapped, so this permutation is \\((13)\\).\n\n3.2.1 Transpositions\nCycles of length \\(2\\) are called transpositions. E.g. \\((14)\\) is a transposition which switches \\(1\\) and \\(4\\). The picture above represents a composition of \\(3\\) transpositions \\((13) = (12)(23)(12)\\).\n\nTheorem 3.1 (Product of transpositions)  \n\nEvery permutation can be written as a product of transpositions\nEvery permutation can be written as a product of transpositions of adjacent elements.\n\nAnother way to say this is that by swapping pairs of elements at a time, we can obtain any possible shuffle.\n\n\nProof. We know that a permutation may be written in terms of cycles. So if we can show that any cycle can be written as a successive sequence of swaps we are good. We will give a visual demonstration of this fact:\n\nB.&lt;t1,t2,t3,t4,t5&gt; = BraidGroup(6)\nplot(t1 * t2 * t3 * t4 * t5)\n\n\n\n\n\n\n\n\nSo the cycle \\((123456) = (12)(23)(34)(45)(56)\\). Remember that compositions are read from right to left: e.g. \\((f \\circ g)(i) = f(g(i))\\) means first do \\(g\\) then do \\(f\\).\nThis kind of decomposition generalizes: you can replace \\((123456)\\) with any cycle of any length. E.g. \\((1456) = (14)(45)(56)\\) although one more reminder that products in SageMath are backwards from the function composition standpoint:\n\nS = SymmetricGroup(6)\nS((5,6)) * S((4,5)) * S((1,4))\n\n(1,4,5,6)\n\n\n\nFor an alternative proof, this decomposition into a sequence of adjacent swaps is exactly how the sorting algorithm BubbleSort works. We can sort any list using BubbleSort which does only adjacent swaps. So the shuffle is obtained by reversing those swaps to go from sorted to shuffled.\n\n\n3.2.2 Braids versus permutations\nYou may have noticed in what we did, the word “braid” was used. Braids are similar to permutation except that we keep track of which strand goes above and which strand goes below. E.g. the transposition \\((12)\\) applied twice looks like\n\nB.&lt;a,b&gt; = BraidGroup(3)\nplot(a * a)\n\n\n\n\n\n\n\n\nAs a permutation this is the trivial shuffle \\(123\\). But as a braid it is still twisted.\nWhile we are only focused on permutations rather than braids here, we still make use of braids because SageMath is able to create diagrams for us.\n\n3.2.2.1 The Braid Group in SageMath\nThe generators of the braid group are adjacent swaps. So the line B.&lt;a, b&gt; = BraidGroup(3) sets a to a swap of \\(1, 2\\) and sets b to a swap of \\(2, 3\\). We can obtain the reverse swap with a^-1 or b^-1\n\nplot(a^-1 * a^-1)\n\n\n\n\n\n\n\n\nWhen converting from braids to permutations, we ignore whether a strand goes over or under and just focus on the swapping.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Visual representations of permutations</span>"
    ]
  },
  {
    "objectID": "generators.html",
    "href": "generators.html",
    "title": "4  Generators",
    "section": "",
    "text": "4.1 Squaring relation\nWe have \\(\\tau_i^2 = 1\\) where \\(1\\) represents the identity permutation (no shuffling). This says that if we swap \\(i\\) and \\(i + 1\\) and then swap again, we get back to a sorted list.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "generators.html#commutating",
    "href": "generators.html#commutating",
    "title": "4  Generators",
    "section": "4.2 Commutating",
    "text": "4.2 Commutating\nFrom Exercise 2.1, we saw that in general \\(\\pi_1 \\pi_2 \\neq \\pi_2 \\pi_1\\). Nonetheless, if we are swapping disjoint sets of pairs like \\((12)\\) followed by \\((34)\\) then there is no interaction between the swaps. So the order doesn’t matter: \\((12)(34) = (34)(12)\\).\n\nB.&lt;a,b,c&gt; = BraidGroup(4)\nplot(a * c)\n\n\n\n\n\n\n\n\n\na * c == c * a\n\nTrue",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "generators.html#aba-bab",
    "href": "generators.html#aba-bab",
    "title": "4  Generators",
    "section": "4.3 ABA = BAB",
    "text": "4.3 ABA = BAB\nAt the top of Section 3.2 we saw that \\((12)(23)(12) = (13)\\). We also have \\((23)(12)(23) = (13)\\). Compare the following pictures.\nB.&lt;a,b&gt; = BraidGroup(3)\nplot(a * b * a)\nplot(b * a * b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can see visually that the middle green strand is sliding from one side of the blue/red crossing to the other.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Generators</span>"
    ]
  }
]