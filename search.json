[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Combinatorics Notes",
    "section": "",
    "text": "About\nNotes for applied combinatorics, intended to supplement the book Applied Combinatorics by Keller and Trotter\nContains:\n\nAn alternate proof of the Inclusion/Exclusion formula and a fully worked out proof of the Euler Totient formula\nNotes on the structure of permutations (cycles, inversions, signs)\nNotes on generating functions formalized through regular languages\nNotes on finite state automata and their connection to regular languages and generating functions\n\n\nThis work © 2024 by Sera Gunn is licensed under CC BY-SA 4.0",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "1  Preface",
    "section": "",
    "text": "These notes were developed to accompany MTH 337: Applied Combinatorics during the Spring semester of 2024. They are meant to be used interspersed with the material from Keller and Trotter’s book Applied Combinatorics. Both these notes and Keller and Trotter’s book are intended to have a heavy algorithmic and applied focus.\nA sample syllabus is (KT is Keller and Trotter’s book)\n\nKT-2: Strings, Sets, and Binomial Coefficients\nKT-3: Induction\nKT-4.1: Pidgeonhole\n\nCan cover the rest of KT-4 if students haven’t seen “big-O” in their other courses yet\n\nKT-5: Graph Theory\nKT-7 and Inclusion-Exclusion from these notes for supplementary proofs\nPermutations from these notes\nKT-12, 13, 14 on graph algorithms (Prim/Kruskal, Dijkstra, Ford-Fulkerson/Edmonds-Karp)\nGenerating Functions from these notes (instead of KT-8)\nRegular Languages from these notes\n\nHere is a rough overview of how these notes tie into the Keller/Trotter book.\n\n\n\n\n\nflowchart\n    KT2-Foundations --&gt; KT7-Inclusion/Exclusion\n    KT2-Foundations --&gt; Permutations\n    KT2-Foundations --&gt; GeneratingFunctions\n    KT7-Inclusion/Exclusion &lt;--&gt; Inclusion/Exclusion\n    GeneratingFunctions --&gt; RegularLanguages\n    KT5-Graphs --&gt; Permutations\n    KT5-Graphs --&gt; RegularLanguages\n    LinearAlgebra -.. Transfer Matrix Method ..-&gt; RegularLanguages\n\n\n\n\n\n\nInclusion/Exclusion makes a very brief appearance Note 21.1 but is otherwise separate in these notes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "trees/trees.html",
    "href": "trees/trees.html",
    "title": "2  Trees",
    "section": "",
    "text": "2.1 Properties of Graphs and Trees\nConsider the graph where the set of vertices are \\(V = \\{1, 2, 3, 4, 5\\}\\) and the edges are \\(\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,1\\}\\) and \\(\\{1,5\\}\\). Graphs such of these are more easily depicted as pictures. We try as much as possible to talk about the picture rather than sets of numbers.\nPer the definition, a graph is labelled (usually the vertices are \\(1, \\dots, n\\)). Graph theory has a lot of applications and theory has a lot of applications and results in which these labels play no role and so we also have simplified pictures where we do not write down the vertex number (however they still exist in the background).\nTrees are common structures in a lot of computer science applications. For instance, filetrees are examples of trees.\nMany applications have a hierarchical picture to tree but this visual hierarchy is not part of our base definition (although we can always add a hierarchy on top of the definition). Here is that same tree but without the hierarchy as part of the picture\nThe first property is called the handshaking lemma or degree sum formula.",
    "crumbs": [
      "Trees",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Trees</span>"
    ]
  },
  {
    "objectID": "trees/trees.html#properties-of-graphs-and-trees",
    "href": "trees/trees.html#properties-of-graphs-and-trees",
    "title": "2  Trees",
    "section": "",
    "text": "Definition 2.3 The degree of a vertex, \\(\\deg(v)\\) is the number of other vertices \\(w\\) for which there is an edge between \\(v\\) and \\(w\\). For instance, the vertex a below has a degree of 3 because it is connected to 3 other vertices: b, d, e.\n\n\n\n\n\n\n\nG\n\n\n\na\n\na\n\n\n\nb\n\nb\n\n\n\na--b\n\n\n\n\nd\n\nd\n\n\n\na--d\n\n\n\n\nc\n\nc\n\n\n\nb--c\n\n\n\n\ne\n\ne\n\n\n\nd--e\n\n\n\n\ne--a\n\n\n\n\n\n The vertex a has a degree of 3 \n\n\n\n\n\n2.1.1 Double Counting\nAn important idea in combinatorics is double counting where we count the same thing in two different ways. For instance, in the above graph we can count the edges just by looking at the picture (5 edges). Or…we can go vertex by vertex and count the edges at that vertex: a has 3, b has 2, c has 1, d and e both have 2. This gives 10 total. If we think carefully about what is going on here, this second method of vertex-by-vertex counts every edge twice. For instance the edge between a and b contributes both to the count for a and for b. This idea is called the handshaking lemma or degree-sum formula.\n\nTheorem 2.1 If we go vertex by vertex and add up the number of edges at that vertex (i.e. the degree) every edge is counted exactly twice.\n\\[\n\\sum \\deg(v) = 2|E|.\n\\]",
    "crumbs": [
      "Trees",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Trees</span>"
    ]
  },
  {
    "objectID": "trees/trees.html#leaf-vertices",
    "href": "trees/trees.html#leaf-vertices",
    "title": "2  Trees",
    "section": "2.2 Leaf Vertices",
    "text": "2.2 Leaf Vertices\nIn developing a developing an understanding of all the properties that trees have, one foundational fact is that every tree with at least two vertices has a leaf vertex where a leaf vertex is a vertex with degree 1.\n\nIn a filesystem, any file is a leaf where its unique edge is the edge connecting it to the parent folder. Additionally, any empty folder (that is not the topmost folder) is also a leaf.\n\n\n\n\n\n\n\n\nG\n\n\n\n1\n\n1\n\n\n\n2\n\n2\n\n\n\n1--2\n\n\n\n\n5\n\n5\n\n\n\n1--5\n\n\n\n\n3\n\n3\n\n\n\n2--3\n\n\n\n\n4\n\n4\n\n\n\n3--4\n\n\n\n\n7\n\n7\n\n\n\n3--7\n\n\n\n\n6\n\n6\n\n\n\n5--6\n\n\n\n\n8\n\n8\n\n\n\n5--8\n\n\n\n\n9\n\n9\n\n\n\n8--9\n\n\n\n\n\n In this tree, vertices 4, 6, 7, 9 are leaves \n\n\n\nI want to take a moment here also to point out that the tree is the data of which vertices are connected and in particular lengths and directions of edges are not part of the data. So we could draw the tree with the vertices placed elsewhere and it will still be the same tree with the same leaves.\n\n\n\n\n\n\n\nG\n\n\n\n1\n\n1\n\n\n\n2\n\n2\n\n\n\n1--2\n\n\n\n\n5\n\n5\n\n\n\n1--5\n\n\n\n\n3\n\n3\n\n\n\n2--3\n\n\n\n\n4\n\n4\n\n\n\n3--4\n\n\n\n\n7\n\n7\n\n\n\n3--7\n\n\n\n\n6\n\n6\n\n\n\n5--6\n\n\n\n\n8\n\n8\n\n\n\n5--8\n\n\n\n\n9\n\n9\n\n\n\n8--9\n\n\n\n\n\n The same tree with a different drawing \n\n\n\n\n2.2.1 Every tree has at least one leaf\nIt is a fact that every tree with 2 or more vertices has at least one (in fact at least two) leaf vertex. We will discuss the why of this (the proof) in a couple levels of formality.\n\n\n\n\n\n\nNote\n\n\n\nThe reason we say here “2 or more vertices” is because if we have only a single vertex that vertex would have no edges (degree 0) and would not be a leaf because a leaf needs to have exactly one edge.\n\n\n\n2.2.1.1 Informal proof\nLets pick any vertex, maybe vertex 1. We have two possibilities 1. this vertex is a leaf (and we have what we were looking for) 2. this vertex has at least two neighbours and in the picture we will call those 2 and 3\n\n\n\n\n\n\n\nG\n\n\n\n2\n\n2\n\n\n\n1\n\n1\n\n\n\n2--1\n\n\n\n\n3\n\n3\n\n\n\n1--3\n\n\n\n\n\n\n\n\n\nNow repeat this reasoning: either 2 or 3 are leaves or they too have a new neighbour other than 1.\n\n\n\n\n\n\nNoteImportant point\n\n\n\nAll of these new neighbours are distinct (e.g. the new neighbour for 2 is not the same as the new neighbour for 3). If lets say the new neighbour for 2 and 3 were the same well then that would create a cycle (not allowed)\n\n\n\n\n\n\n\nG\n\n\n\n4\n\n4\n\n\n\n2\n\n2\n\n\n\n4--2\n\n\n\n\n1\n\n1\n\n\n\n2--1\n\n\n\n\n3\n\n3\n\n\n\n1--3\n\n\n\n\n3--4\n\n\n\n\n\n\n\n\n\n\n\nSo as long as we never hit a leaf vertex we can always find more vertices. But there are only a finite amount of vertices so we cannot continue this indefinitely. At some point we have to find a leaf vertex (and in fact, one on each side).\n\n\n2.2.1.2 Induction\nThis idea of “just keep going and eventually we have to stop because there was only a finite number” has a name. It is known as the principle of mathematical induction. Suppose we show two things: 1. the minimal sized case(s) have a property 2. any big case can be made into a smaller case then we are done because any case can be made smaller and smaller until we eventually find what we are looking for and the process stops because everything is finite.\nIn terms of trees, the minimal case is a tree consisting of a pair of vertices and a single edge. Each vertex here is a leaf edge.\n\n\n\n\n\n\n\nG\n\n\n\na\n\n\n\n\nb\n\n\n\n\na--b\n\n\n\n\n\n Minimal tree with 2 vertices \n\n\n\nNow suppose we have a larger, more complex tree. Focus on a single edge somewhere in the tree, let us call its endpoints a and b.\n\n\n\n\n\n\n\nG\n\n\n\na\n\na\n\n\n\nb\n\nb\n\n\n\na--b\n\n\n\n\n4\n\n\n\n\nb--4\n\n\n\n\n5\n\n\n\n\nb--5\n\n\n\n\n1\n\n\n\n\n1--a\n\n\n\n\n2\n\n\n\n\n2--a\n\n\n\n\n3\n\n\n\n\n3--a\n\n\n\n\n\n Larger tree focusing on the edge ab \n\n\n\nIf neither a nor b are leaves then we smush the two vertices together merging the entire edge into single vertex which we will label “ab.” This process is known as edge contraction.\n\n\n\n\n\n\n\nG\n\n\n\nab\n\nab\n\n\n\n4\n\n\n\n\nab--4\n\n\n\n\n5\n\n\n\n\nab--5\n\n\n\n\n1\n\n\n\n\n1--ab\n\n\n\n\n2\n\n\n\n\n2--ab\n\n\n\n\n3\n\n\n\n\n3--ab\n\n\n\n\n\n Contracting the edge. \n\n\n\nBy contracting the edge we create a smaller graph with one fewer vertex and one fewer edge.\nThis process may be carried out again and again. Choose a new edge, either we find a leaf vertex or we contract. Because we cannot contract indefinitely we say now “by induction” there must be a leaf vertex.\n\n\n2.2.1.3 A little bit more formal\nGoing the next step, induction is often thought about as “going up” rather than “going down.” We worded the last argument as creating smaller and smaller graphs but another way to say that is\n\nEvery tree with two vertices (there is only one such tree) has a leaf vertex\nEvery tree with three vertices may be smushed (contracted) to a tree with two vertices thus every tree with three vertices has a leaf vertex.\nEvery tree with four vertices may be contracted to a tree with three vertices so every tree with four vertices has a leaf vertex\n(Induction is where we observe in formal terms that this pattern extends to all whole numbers)\nEvery tree with \\(n + 1\\) vertices has a leaf vertex because (in the step before) every tree with \\(n\\) vertices has a leaf vertex (because every tree with \\(n - 1\\) vertices has a leaf vertex because every tree with \\(n - 2\\) vertices has a leaf vertex…)\n\nInduction is revisited in Keller and Trotter’s book, chapter 3.\n\n\n\n2.2.2 Counting Leaves\nActually, before we go any further we need another fact\n\nTheorem 2.2 For any tree, there is always exactly one more vertex than edge. I.e. \\(|V| = |E| + 1\\).\n\n\nProof. Have a look at what we did in the previous section for induction.\n\nA tree with 1 vertex has 0 edges\nA tree with 2 vertices has 1 edge\nA tree with 3 vertices has 2 edges\nA tree with \\(n + 1\\) vertices may be smushed into a tree with \\(n\\) vertices. This contraction process removes 1 vertex and 1 edge so the property of “\\(|V| = |E| + 1\\)” is preserved.\n\nSo by induction all trees have \\(|V| = |E| + 1\\).\n\nWhere the last few sections were about induction, this one will show some ideas for enumeration (i.e. counting stuff). Going all the way back up to the Handshake Lemma Theorem 2.1 let us break up that formula a bit in a way that lets us count leaf vertices.\nTo that end, let \\(n_d\\) be the number of vertices of degree \\(d\\). So \\(n_1\\) is the number of vertices of degree 1 (leaf vertices).\n\n\n\n\n\n\nTip\n\n\n\nA common trick in combinatorics is if we have a function like \\(\\deg\\) and we want to count where \\(\\deg = 1\\) then we also count where \\(\\deg = 2, \\deg = 3, \\dots\\) and then later isolate \\(\\deg = 1\\).\n\n\n\n\n\n\n\n\n\nG\n\n\n\n1\n\n\n\n\n2\n\n\n\n\n1--2\n\n\n\n\n5\n\n\n\n\n1--5\n\n\n\n\n3\n\n\n\n\n2--3\n\n\n\n\n10\n\n\n\n\n2--10\n\n\n\n\n11\n\n\n\n\n2--11\n\n\n\n\n4\n\n\n\n\n3--4\n\n\n\n\n7\n\n\n\n\n3--7\n\n\n\n\n6\n\n\n\n\n5--6\n\n\n\n\n8\n\n\n\n\n5--8\n\n\n\n\n9\n\n\n\n\n8--9\n\n\n\n\n\n\n\n\n\nIn this tree, we have \\(n_1 = 6, n_2 = 2, n_3 = 2, n_4 = 1\\). The degree sum is\n\\[\\begin{align*}\n\\sum \\deg(v) &= 1 + 1 + 1 + 1 + 1 + 1 + 2 + 2 + 3 + 3 + 4 \\\\\n&= 1 \\cdot 6 + 2 \\cdot 2 + 3 \\cdot 2 + 4 \\cdot 1 \\\\\n&= 1n_1 + 2n_2 + 3n_3 + 4n_4 = 2|E| = 20\n\\end{align*}\\]\nSo separating the degree sum into \\(n_1, n_2, \\dots\\) we get \\[\n\\sum_v \\deg(v) = \\sum_d d n_d = 2|E|.\n\\] Spelled out: \\[\nn_1 + 2n_2 + 3n_3 + 4n_4 + \\cdots = 2|E|.\n\\]\nNow let us look at a similar sum: \\[\nn_1 + n_2 + n_3 + n_4 + \\cdots\n\\] So that is the number of vertices of degree 1, degree 2, degree 3, … well that is every vertex so this sum is \\(|V|\\). Or, as we learned in Theorem 2.2, \\(|V| = |E| + 1\\).\nSo we have two identities: \\[\\begin{align*}\nn_1 + 2n_2 + 3n_3 + 4n_4 + \\cdots &= 2|E| \\\\\nn_1 + \\phantom{2}n_2 + \\phantom{3}n_3 + \\phantom{4}n_4 + \\cdots &= |E| + 1.\n\\end{align*}\\] Subtract twice the second from the first and we have \\[\n-n_1 + \\phantom{n_2} + n_3 + 2n_4 + \\dots = -2.\n\\]\nAlmost done! Lastly move the \\(-n_1\\) to the right and the \\(-2\\) to the left and we get our main result for this section.\n\nTheorem 2.3 In any tree (with at least two vertices), the number of leaves is \\[\nn_1 = 2 + n_3 + 2n_4 + 3n_5 + 4n_6 + \\cdots\n\\]\n\nThis tells us a few interesting things all at once!\n\nCorollary 2.1 Every tree with at least two vertices has at least two leaves: \\(n_1 \\ge 2\\).\n\n\nCorollary 2.2 Moreover, for every vertex of degree 3 there is an additional leaf. For every vertex of degree 4 there are 2 additional leaves and so on.\n\nWe can look at this last result in another way: take a vertex (let’s say of degree 4) and follow the 4 edges until they lead to leaves. So this degree 4 vertex gives 4 leaves at least (more if there are other branches to follow).\n\n\n\n\n\n\n\nG\n\n\n\na\n\n\n\n\n1\n\n\n\n\na--1\n\n\n\n\n2\n\n\n\n\na--2\n\n\n\n\n3\n\n\n\n\na--3\n\n\n\n\n4\n\n\n\n\na--4\n\n\n\n\n5\n\n\n\n\n1--5\n\n\n\n\n7\n\n\n\n\n2--7\n\n\n\n\n8\n\n\n\n\n3--8\n\n\n\n\n6\n\n\n\n\n5--6\n\n\n\n\n\n a degree 4 vertex leading to four leaves",
    "crumbs": [
      "Trees",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Trees</span>"
    ]
  },
  {
    "objectID": "strings/forbidden.html",
    "href": "strings/forbidden.html",
    "title": "3  Forbidden Substrings",
    "section": "",
    "text": "3.1 Decomposing the problem\nMotivating questions:\nLet’s look at all the binary strings of length \\(5\\) that do not contain “11”:\nWhich matches with the 7th Fibonacci number: 1, 1, 2, 3, 5, 8, 13.\nTo understand why, let us split this list into two smaller lists. First, those sequences which start with a 0:\nand with a 1:\nAnd here we see that \\(13 = 8 + 5\\) decomposes this Fibonacci number into the sum of the two previous ones.\nObservation: every string that starts with a 1, in fact starts with 10. If we remove this 10 from each string, we get the list of strings of length 3. Likewise, if we remove the 0 from the first list we get the list of strings of length 4. That is, we have a decomposition:\n\\[\\begin{align*}\n\\text{strings of length n} &= \\text{strings that start with 0} + \\text{strings that start with 10} \\\\\n&\\equiv \\text{strings of length n - 1} + \\text{strings of length n - 2}\n\\end{align*}\\]",
    "crumbs": [
      "Strings",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Forbidden Substrings</span>"
    ]
  },
  {
    "objectID": "strings/forbidden.html#decomposing-the-problem",
    "href": "strings/forbidden.html#decomposing-the-problem",
    "title": "3  Forbidden Substrings",
    "section": "",
    "text": "00000\n00001\n00010\n00100\n01000\n10000\n00101\n01001\n10001\n01010\n10010\n10100\n10101\n\n\n\n\n00000\n00001\n00010\n00100\n01000\n00101\n01001\n01010\n\n\n\n10000\n10001\n10010\n10100\n10101\n\n\n\n\n\n\n\n\n\n\nNoteNotation\n\n\n\nHere we use the \\(\\equiv\\) symbol to mean equinumerous, i.e. having the same size/count as opposed to being literally equal as sets.",
    "crumbs": [
      "Strings",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Forbidden Substrings</span>"
    ]
  },
  {
    "objectID": "strings/forbidden.html#introducing-notation",
    "href": "strings/forbidden.html#introducing-notation",
    "title": "3  Forbidden Substrings",
    "section": "3.2 Introducing notation",
    "text": "3.2 Introducing notation\nFor this problem, it will be useful to have a notation that means “strings of length \\(n - k\\) that start with \\(u\\),” still subject to the forbidden substring condition. We will call this \\([u]_k\\). E.g”.\n\n\\([\\;]=\\) strings of length \\(n\\)\n\\([\\;]_1=\\) strings of length \\(n - 1\\)\n\\([1]=\\) strings of length \\(n\\) that begin with a “1”\n\\([101]_2=\\) strings of length \\(n - 2\\) that begin with “102”\netc.\n\nThe previous decomposition can now be written as\n\\[\\begin{align*}\n[\\;] &= [0] + [10] \\\\\n&\\equiv [\\;]_1 + [\\;]_2.\n\\end{align*}\\]\n\n3.2.1 Recursive relations\nContinuing the previous problem, let \\(s_n\\) equal the number of binary strings of length \\(n\\) that do not contain “11.” So \\(s_n = \\#[\\;]\\) and \\(s_{n - k} = \\#[\\;]_k\\). Thus, we have here\n\\[s_n = s_{n - 1} + s_{n - 2}.\\]\n\n\n\n\n\n\nNoteNotation\n\n\n\nSequences are often written using subscript notation like \\(s_0, s_1, s_2, \\dots\\) but we can also write them using a more function-like notation \\(f(0), f(1), f(2), \\dots\\). The choice of which notation to use is personal preference.\n\n\nFor any given problem, we usually want to compute the initial few terms of the sequence as well. Here we have\n\n\\(s_0 = 1\\) since there is only one string of length 0 namely “” (an empty string)\n\\(s_1 = 2\\) since the two strings of length 1 are “0” and “1”\n\\(s_2 = 3\\) with the strings being “00”, “01”, “10”\n\nMeaning our sequence goes \\(1, 2, 3, 5, 8, 13, 21, \\dots\\) (starting in index 0).",
    "crumbs": [
      "Strings",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Forbidden Substrings</span>"
    ]
  },
  {
    "objectID": "strings/forbidden.html#more-examples",
    "href": "strings/forbidden.html#more-examples",
    "title": "3  Forbidden Substrings",
    "section": "3.3 More Examples",
    "text": "3.3 More Examples\n\nExample 3.1 How many binary strings are there of length \\(n\\) that do not contain “10”?\nWe start with the decomposition \\[ [\\;] = [0] + [1]. \\] (A binary string either starts with a 0 or a 1.)\nNext, if the string starts with a 0 it can be followed by any valid string of length \\(n - 1\\) so \\[ [0] \\equiv [\\;]_1. \\] (Strings that start with 0 are equinumerous with strings of length \\(n - 1\\).) So here the count is \\(s_{n - 1}\\).\nIf the string starts with a 1, then it must be followed by a 1, and by another 1, etc. No 1 may be followed by a 0. Therefore \\[ [1] = \\{11\\dots111\\}. \\] (The only string the starts with a 1 is the string consisting of only 1s.) So here the count is just \\(1\\).\nPutting this together, we have \\[ s_n = s_{n-1} + 1 \\]\nIn fact, the complete set of such strings is \\(00\\dots0011\\dots11\\) (any number of 0s followed by any number of 1s) and there are \\(n + 1\\) in total: \\(s_n = n + 1\\).\n\nThis last problem was a bit unusual because there was exactly one string that starts with a 1. If we increase the base from binary to ternary we will have a bit more flexibility.\n\nExample 3.2 How many ternary strings are there of length \\(n\\) that do not contain “10”? (Compare: KT exercise 3.11.3)\nThis time, \\[\\begin{align*}\n[\\;] &= [0] + [1] + [2] \\\\\n&\\equiv [\\;]_1 + [1] + [\\;]_1\n\\end{align*}\\]\nWe also have \\[ [1] \\equiv [\\;]_1 - [0]_1 \\equiv [\\;]_1 - [\\;]_2. \\]\nSo therefore \\[\\begin{align*}\n[\\;] &\\equiv 3[\\;]_1 - [\\;]_2 \\\\\ns_n &= 3s_{n - 1} - s_{n - 2}.\n\\end{align*}\\]\n\nThe decomposition we did in Example 3.2 would have also worked in binary case in Example 3.1. That would give us (for binary strings) \\[\ns_n = 2s_{n - 1} - s_{n - 2}\n\\]\nDespite this being a different recursive relation, the solution we found \\(s_n =\nn + 1\\) satisfies both of these recursive relations.\n\nExample 3.3 How many ternary strings are there of length \\(n\\) that do not contain “102”? (KT example 3.6)\nStart with \\[\n[\\;] = [0] + [1] + [2].\n\\] If a string starts with 0 or 2 we don’t care what comes next: \\[\n[\\;] \\equiv [\\;]_1 + [1] + [\\;]_1 = 2[\\;]_1 + [1].\n\\]\nStrings that start with 1 are not followed by 02: \\[\n[1] \\equiv [\\;]_1 - [02]_1 \\equiv [\\;]_1 - [\\;]_3.\n\\] (A string that starts with 1 is the same as any string of length \\(n - 1\\) except those that start \\(02\\). Strings of length \\(n - 1\\) that start 02 are equinumerous to any string of length \\(n - 3\\).)\nTogether: \\[[\\;] \\equiv 2[\\;]_1 + ([\\;]_1 - [\\;]_3) = 3[\\;]_1 - [\\;]_3.\\] And lastly, as a recursive formula, \\[ s_n = 3s_{n - 1} - s_{n - 3}. \\]",
    "crumbs": [
      "Strings",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Forbidden Substrings</span>"
    ]
  },
  {
    "objectID": "strings/forbidden.html#excluding-multiple-strings",
    "href": "strings/forbidden.html#excluding-multiple-strings",
    "title": "3  Forbidden Substrings",
    "section": "3.4 Excluding multiple strings",
    "text": "3.4 Excluding multiple strings\nOur technique also applies if we consider forbidding multiple strings. (KT exercise 3.11.5)\n\nExample 3.4 How many base-4 strings do not contain either “12” or “20” as a substring?\nAs always, any digit that isn’t a leading digit for our forbidden substrings is equinumerous with \\([\\;]_1\\). So \\[\\begin{align*}\n[\\;] &= [0] + [1] + [2] + [3] \\\\\n&\\equiv 2[\\;]_1 + [1] + [2].\n\\end{align*}\\]\nStrings that start with 1 cannot be followed by a 2: \\[\n[1] \\equiv [\\;]_1 - [2]_1\n\\] Strings that start with a 2 cannot be followed by a 0: \\[\n[2] \\equiv [\\;]_1 - [0]_1 \\equiv [\\;]_1 - [\\;]_2.\n\\]\nWe can substitute this second relation into the first, remembering to add the offsets \\[\n[1] \\equiv [\\;]_1 - [\\;]_2 + [\\;]_3\n\\]\nAnd now putting everything together: \\[\\begin{align*}\n[\\;] &\\equiv 4[\\;]_1 - 2[\\;]_2 + [\\;]_3 \\\\\ns_n &= 4s_{n - 1} - 2s_{n - 2} + s_{n - 3}\n\\end{align*}\\]",
    "crumbs": [
      "Strings",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Forbidden Substrings</span>"
    ]
  },
  {
    "objectID": "strings/forbidden.html#self-overlapping-strings",
    "href": "strings/forbidden.html#self-overlapping-strings",
    "title": "3  Forbidden Substrings",
    "section": "3.5 Self-overlapping strings",
    "text": "3.5 Self-overlapping strings\n\n\n\n\n\n\nCaution\n\n\n\nThe ideas here are more advanced, we will return to them later on in the course when we talk about generating functions.\n\n\nSomething interesting happens if we change Example 3.3 to ternary strings forbidding “101” because “101” can overlap with itself: \\[\\begin{align*}\n\\mathtt{101..} \\\\\n\\mathtt{..101}\n\\end{align*}\\]\nMeaning if we want to know how many strings start with a 1 we need to know 2 places later how many start with a 1 and then another 2 places later and another 2 places later…\n\\[\\begin{align*}\n[1] &\\equiv [\\;]_1 - [01]_1 \\\\\n&\\equiv [\\;]_1 - [1]_2 \\\\\n&\\equiv [\\;]_1 - ([\\;]_3 - [1]_4) \\\\\n&\\equiv [\\;]_1 - [\\;]_3 + [\\;]_5 - [\\;]_7 + \\cdots\n\\end{align*}\\]\nAnd this is okay, but we have an infinite length recursive relation which is not ideal.\nOne way to help analyse this is to treat this as more of an equation. And for that, the trick is to write \\([u]_k = [u]x^k\\) so we can solve for things in terms of \\(x\\). (Just roll with this for a minute.)\n\\[\\begin{align*}\n[1] &= [\\;]x - [1]x^2 \\\\\n[1] + x^2[1] &= [\\;]x \\\\\n(1 + x^2)[1] &= [\\;]x \\\\\n[1] &= [\\;] \\frac{x}{1 + x^2}\n\\end{align*}\\]\nOr as a Taylor series, \\[\n[1] = [\\;](x - x^3 + x^5 - x^7 + \\cdots)\n\\]\nAnd ok this hasn’t yet produced something new but let’s see how this fits in to the rest of the solution.\n\\[\n[\\;] = [0] + [1] + [2] + 1\n\\]\n\n\n\n\n\n\nTipHold up\n\n\n\nWe added a “+1”?? Yeah so when we work with \\(x\\)’s like this, these \\([u]\\) symbols now represent strings of any length. While strings of length \\(n\\) start with 0, 1 or 2, the unique string of length 0, ““, starts with none of these so we have to include a +1 to represent that.\n\n\n\\[\\begin{align*}\n[\\;] &= [0] + [1] + [2] + 1 \\\\\n&= 2[\\;]x + [\\;] \\frac{x}{1 + x^2} + 1 \\\\\n[\\;] \\left(1 - 2x - \\frac{x}{1 + x^2} \\right) &= 1 \\\\\n[\\;] &= \\frac{1}{1 - 2x - \\frac{x}{1 + x^2}}\n\\end{align*}\\]\nThis simplifies to \\[\n[\\;] = \\frac{1 + x^2}{1 - 3x + x^2 - 2x^3}\n\\]\nAnd now we use the computer for help getting a Taylor series for this\n\n\n\nThe coefficients here tell us how many strings there are of that length: \\[\\begin{align*}\ns_0 &= 1 \\\\\ns_1 &= 3 \\\\\ns_2 &= 9 \\\\\ns_3 &= 26 \\\\\ns_4 &= 75 \\\\\ns_5 &= 217 \\\\\ns_6 &= 628\n\\end{align*}\\] etc.\nThe technique we have used here is called a generating function and we will return to this subject later on.\nGenerating functions help us sort out really entangled recursive relations and self-overlapping strings.",
    "crumbs": [
      "Strings",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Forbidden Substrings</span>"
    ]
  },
  {
    "objectID": "strings/string-exercises.html",
    "href": "strings/string-exercises.html",
    "title": "4  Exercises",
    "section": "",
    "text": "Find a recursive relation for\n\nBinary strings that do not contain “100”\nTernary strings that do not contain “100”\nBase-5 strings that do not contain “1234”\nTernary strings that do not contain “100” or “02”",
    "crumbs": [
      "Strings",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/inclusion-exclusion.html",
    "href": "inclusion-exclusion/inclusion-exclusion.html",
    "title": "5  Inclusion/Exclusion",
    "section": "",
    "text": "5.1 For two sets\nGiven two sets \\(A\\) and \\(B\\), we can compute \\(|A \\cup B|\\) by first adding everything in \\(A\\) and adding everything in \\(B\\). This counts all of \\(A \\cup B\\) except the items in \\(A \\cap B\\) were counted twice. Thus\n\\[\n|A| + |B| = |A \\cup B| + |A \\cap B|.\n\\]",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/inclusion-exclusion.html#for-two-sets",
    "href": "inclusion-exclusion/inclusion-exclusion.html#for-two-sets",
    "title": "5  Inclusion/Exclusion",
    "section": "",
    "text": "Example 5.1 Suppose there are \\(100\\) CS students an a school. Of these, \\(50\\) know Java and \\(60\\) know Python (everyone knows at least one of these two languages). If we add \\(50 + 60\\) we get the \\(100\\) total students plus \\(10\\) students who know both.\n\\[\n50 + 60 = 100 + 10.\n\\]",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/inclusion-exclusion.html#for-three-sets",
    "href": "inclusion-exclusion/inclusion-exclusion.html#for-three-sets",
    "title": "5  Inclusion/Exclusion",
    "section": "5.2 For three sets",
    "text": "5.2 For three sets\n\n\n\nInclusion/Exclusion for 3 sets\n\n\nWe can do a similar process for three sets. Start by adding up \\(|A| + |B| + |C|\\) then subtract all the intersections of pairs then add back in \\(|A \\cap B \\cap C|\\). For items in each region of the Venn diagram, think about how many times an item is added/subtracted overall.\nE.g. items in \\(A\\) and \\(B\\) but not \\(C\\) will be added in twice in the first step (\\(|A| + |B|\\)) and subtracted once in the second step (\\(|A \\cap B|\\)) so they are counted once.\nItems in \\(A \\cap B \\cap C\\) are added in \\(3 - 3 + 1 = 1\\) times.",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/inclusion-exclusion.html#sec-binomials-and-IE",
    "href": "inclusion-exclusion/inclusion-exclusion.html#sec-binomials-and-IE",
    "title": "5  Inclusion/Exclusion",
    "section": "5.3 Binomial coefficients and I/E",
    "text": "5.3 Binomial coefficients and I/E\nSuppose we are looking at a union of \\(n\\) sets: \\(A_1 \\cup \\dots \\cup A_n\\). Consider an element \\(x\\) belonging exactly to \\(A_1, \\dots, A_m\\) and no other sets. If we do the same procedure of adding \\(|A_1| + \\dots + |A_n|\\) then we are counting \\(x\\) a total of \\(m\\) times. Then, when we subtract all the pairwise intersections, \\(|A_i \\cap A_j|\\), we are subtracting from the count of \\(x\\) a total of \\(\\binom{m}{2}\\) because there are \\(\\binom{m}{2}\\) ways to choose two indices \\(\\{i, j\\} \\subset \\{1, \\dots, m\\}\\).\nThus, if we alternate: adding in single sets, subtracting pairs of intersections, adding triples, subtracting quadruples, etc. we are counting \\(x\\) a total of\n\\[\n\\binom{m}1 - \\binom{m}2 + \\binom{m}3 -  \\binom{m}4 + \\cdots\n\\tag{5.1}\\] times.\nLet’s have a closer look at this. We know the Binomial Theorem says that \\[\n(1 + x)^m = \\binom{m}0x^0 + \\binom{m}1x^1 + \\binom{m}2x^2 + \\dots + \\binom{m}mx^m.\n\\] Substituting \\(x = -1\\), we get\n\\[\n0 = \\binom{m}0 - \\binom{m}1 + \\binom{m}2 - \\dots + \\binom{m}m (-1)^m.\n\\]\nAnd since \\(\\binom{m}0 = 1\\), if we move all the other terms to the other side of the equation, we see that Equation 5.1 evaluates to \\(1\\).\n\n\n\n\n\n\nNote 5.1\n\n\n\nFor this problem we are counting the size of \\(A_1 \\cup \\dots \\cup A_n\\) so each element is in at least one set (\\(m \\ge 1\\)). This is important so that we can say that \\(0^m = 0\\). In the context of the binomial theorem, \\((1 - 1)^0 = \\binom{0}{0} = 1\\). This will be important later when we want to count elements not belonging to any set.\n\n\nThe general I/E formula is then\n\\[\\begin{align*}\n|A_1 \\cup \\dots \\cup A_n| &= \\sum_i |A_i| - \\sum_{i &lt; j} |A_i \\cap A_j| + \\sum_{i &lt; j &lt; k} |A_i \\cap A_j \\cap A_k| - \\dots \\\\\n&= \\sum_{t = 1}^n (-1)^{t + 1} \\sum_{i_1 &lt; \\dots &lt; i_t} |A_{i_1} \\cap \\dots \\cap A_{i_t}|.\n\\end{align*}\\]\nNote: \\((-1)^{t + 1}\\) takes the values \\(1, -1, 1, -1, \\dots\\) starting at \\(t = 1\\).",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/inclusion-exclusion.html#sec-avoiding",
    "href": "inclusion-exclusion/inclusion-exclusion.html#sec-avoiding",
    "title": "5  Inclusion/Exclusion",
    "section": "5.4 Avoiding properties",
    "text": "5.4 Avoiding properties\nInclusion/Exclusion appears most frequently in combinatorics not as a means to count \\(|A_1 \\cup \\dots \\cup A_n|\\) directly but rather as a means to count everything not in \\(A_1 \\cup \\dots \\cup A_n\\).\nFor example, let $[m] = {1,,m} and suppose we want to count the number of functions \\(f : [m] \\to [n]\\) which don’t miss anything in the codomain. I.e. if \\(A_i\\) is the set of functions where \\(f(x)\\) never equals \\(i\\), then we want to count every function not in any set \\(A_i\\).\nLet \\(X\\) be the total set of functions. Then to count the functions avoiding \\(A_1 \\cup \\dots \\cup A_n\\) we do\n\\[\\begin{align*}\n|X \\setminus (A_1 \\cup \\dots A_n)| &= |X| - |A_1 \\cup \\dots A_n| \\\\\n&= |X| - \\sum_i |A_i| + \\sum_{i &lt; j} |A_i \\cap A_j| - \\cdots\n\\end{align*}\\]\n\n\n\n\n\n\nCautionCaution\n\n\n\nThe formula \\(|A \\setminus B| = |A| - |B|\\) works only when \\(B\\) is contained entirely inside \\(A\\).",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/inclusion-exclusion.html#simplifying-notation.",
    "href": "inclusion-exclusion/inclusion-exclusion.html#simplifying-notation.",
    "title": "5  Inclusion/Exclusion",
    "section": "5.5 Simplifying notation.",
    "text": "5.5 Simplifying notation.\nLet \\(\\mathscr{P} = \\{P_1, \\dots, P_n\\}\\) be a collection of sets representing negative properties—conditions we want to avoid. For a subset \\(S \\subseteq \\{1,\\dots,n\\}\\), let \\(N_\\ge(S)\\) be the number of items satisfying at least those properties in \\(S\\). I.e. \\(\\bigcap_{i \\in S} P_i\\). We will say “\\(x\\) satisfies \\(S\\)” for short. Also, if \\(S = \\{a,b,c\\}\\), let us write for example, \\(N_\\ge(a,b,c)\\) instead of \\(N_\\ge(\\{a,b,c\\})\\) for simplicity.\nLet \\(N_{=}(S)\\) be the number of \\(x\\) satisfying exactly those properties in \\(S\\) and no properties not in \\(S\\). When \\(\\mathscr{P}\\) represents properties we wish to avoid, then \\(N_{=}(\\varnothing)\\) is the number of elements satisfying none of the properties.\n\nTheorem 5.1 (Inclusion/Exclusion) \\[\\begin{align*}\nN_{=}(\\varnothing) &= N_{\\ge}(\\varnothing) - \\sum_i N_\\ge(i) + \\sum_{i &lt; j} N_\\ge(i,j) - \\cdots \\\\\n&= \\sum_{S} (-1)^{|S|} N_\\ge(S).\n\\end{align*}\\]\n\n\nProof. As in Section 5.3, we will break up the sum focusing on each element. So first, we will write \\[\n\\sum_{S} (-1)^{|S|} N_\\ge(S) = \\sum_S (-1)^{|S|} \\sum_{\\substack{x \\\\ x \\text{ satisfies } S}} 1\n\\]\nHere we replace the number \\(N_\\ge(S)\\) by a count of \\(1\\) for each element \\(x\\) which satisfies \\(S\\). This introduces a second sum into the picture and that will allow us to swap the order of summations. Currently, the second sum is over all \\(x\\) with respect to the relation “\\(x\\) satisfies \\(S\\).” When we put the sum over \\(x\\) outside, we still have the relation “\\(x\\) satisfies \\(S\\)” but rather than summing over all \\(x\\) with this property, we sum over all \\(S\\):\n\\[\n\\sum_S (-1)^{|S|} \\sum_{\\substack{x \\\\ x \\text{ satisfies } S}} 1 = \\sum_x \\sum_{\\substack{S \\\\ x \\text{ satisfies } S}} (-1)^{|S|}.\n\\]\nWe also move the \\((-1)^|S|\\) inside the second sum because that quantity depends on \\(|S|\\).\nNext, just as we did in Section 5.3, let us say that \\(x\\) satisfies exactly \\(P_{i_1}, \\dots, P_{i_m}\\) (\\(m\\) will depend on \\(x\\)) and let \\(S_x = \\{i_1, \\dots, i_m\\}\\). This set is the largest set that \\(x\\) satisfies. Every other set that \\(x\\) satisfies will be a subset of \\(S_x\\).\nWe now break up our sum based on the size of those subsets \\(S \\subseteq S_x\\), using the binomial coefficients to count the number of such \\(S\\):\n\\[\n\\sum_x \\sum_{\\substack{S \\\\ x \\text{ satisfies } S}} (-1)^{|S|} = \\sum_x \\sum_{k = 0}^m \\underbrace{\\binom{m}{k} (-1)^k}_{\\substack{|S| = k \\text{ and } x \\text{ satisfies } S \\\\ \\iff |S| = k \\text{ and } S \\subseteq S_x}}.\n\\]\nThis, by the Binomial Theorem, is the same as \\[\n\\sum_x (1 - 1)^m.\n\\] Remember here that \\(m\\) depends on \\(x\\).\nAs discussed in Note 5.1, \\(0^m = 0\\) if \\(m \\ge 1\\) but if \\(m = 0\\) then \\(0^0 = 1\\). Saying \\(m = 0\\) means that \\(x\\) satisfies exactly \\(0\\) properties—which is what we are looking for. So the final simplification looks like \\[\n\\sum_x 0^m = \\sum_{\\substack{x \\\\ m = 0}} 1 = N_{=}(\\varnothing).\n\\]",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/inclusion-exclusion.html#application-1-surjections",
    "href": "inclusion-exclusion/inclusion-exclusion.html#application-1-surjections",
    "title": "5  Inclusion/Exclusion",
    "section": "5.6 Application 1: Surjections",
    "text": "5.6 Application 1: Surjections\nAs in Section 5.4, let \\(X\\) be the set of all functions from \\([m]\\) to \\([n]\\) and let \\(P_i\\) be the set of functions where \\(i\\) is never an output: \\(f(x) \\neq i\\) for any input \\(x\\).\n\nLemma 5.1  \n\nThe number of functions from an \\(m\\) element set to an \\(n\\) element set is \\(n^m\\).\nThe number of functions from an \\(m\\) element set to an \\(n\\) element set that avoid \\(k\\) outputs is \\((n - k)^m\\).\n\n\n\nProof. \n\nThere are \\(n\\) choices for \\(f(1)\\) and \\(n\\) choices for \\(f(2)\\), etc. So there are \\(n^m\\) choices in total for \\(f(1), \\dots, f(m)\\).\nIf we are avoiding \\(k\\) outputs then there are only \\(n - k\\) choices for each of \\(f(1),\\dots,f(m)\\) so \\((n - k)^m\\).\n\n\nWith this in mind, we have \\(N_\\ge(S) = (n - k)^m\\) if \\(|S| = k\\) (we avoid at least the specified \\(k\\) outputs). So by inclusion exclusion, the number of functions which avoid no outputs (i.e. surjections) is\n\\[\\begin{align*}\n&N_\\ge(\\varnothing) - \\sum_i N_\\ge(i) + \\sum_{i &lt; j} N_\\ge(i,j) - \\cdots \\\\\n&\\hspace{4em} = n^m - \\sum_i (n - 1)^m + \\sum_{i &lt; j} (n - 2)^m - \\cdots.\n\\end{align*}\\]\nAnd since there are \\(\\binom{n}{k}\\) ways to choose \\(k\\) outputs to avoid, we can also write this as\n\\[\nn^m - \\binom{n}1 (n - 1)^m + \\binom{n}2 (n - 2)^m - \\dots = \\sum_{k} \\binom{n}k (-1)^k (n - k)^m.\n\\]\nThe textbook calls this number \\(S(m,n)\\).\n\n\n\n\n\n\nNoteNote\n\n\n\nIn the above application, \\(N_\\ge(S) = (n - k)^m\\) only depended on the size \\(k\\) of \\(S\\). This is true in many but not all examples.",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/inclusion-exclusion.html#application-2-derangements",
    "href": "inclusion-exclusion/inclusion-exclusion.html#application-2-derangements",
    "title": "5  Inclusion/Exclusion",
    "section": "5.7 Application 2: Derangements",
    "text": "5.7 Application 2: Derangements\nLet \\(X\\) be the set of all permutations of \\([n]\\). We wish to count the permutations with no fixed points. So let \\(P_i\\) be the property that \\(i\\) is a fixed point. Then \\(N_{=}(\\varnothing)\\) is the number of permutations with zero fixed points. This number is called \\(d_n\\) in the textbook.\n\nLemma 5.2  \n\nThe number of permutations of \\([n]\\) is \\(n!\\)\nThe number of permutations with at least \\(k\\) specified fixed points is \\((n - k)!\\)\n\n\n\nProof. \n\nDiscussed in Chapter 2 of the book.\nTo say that there are \\(k\\) specified fixed points means were are permuting the other \\(n - k\\) items. Similar to (a), there are \\((n - k)!\\) ways to permute \\(n - k\\) items.\n\n\nApplying Inclusion/Exclusion, we thus have \\[\nd_n = n! - \\binom{n}1 (n - 1)! + \\binom{n}2 (n - 2)! - \\dots = \\sum_{k} \\binom{n}k (-1)^k (n - k)!.\n\\] Again, there are \\(\\binom{n}k\\) ways to choose a set \\(S\\) of \\(k\\) fixed points and each of these has the same number \\(N_\\ge(S) = (n - k)!\\).",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Inclusion/Exclusion</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/totient.html",
    "href": "inclusion-exclusion/totient.html",
    "title": "6  Euler’s Totient Function",
    "section": "",
    "text": "6.1 The totient function\nConsider the number system of the integers mod \\(n\\). This means we group the numbers based on whether they have the same remainder when divided by \\(n\\). For example, \\(3 \\cdot 7 \\equiv 1 \\pmod {10}\\) because both \\(21\\) and \\(1\\) have the same remainder when divided by \\(10\\).\nThis number system works a lot like the integers. We have addition, subtraction and multiplication. The question is: when can we divide? For example, is it possible to solve \\(2x \\equiv 3 \\pmod{10}\\) for \\(x\\)? I.e. is there a way to move the \\(2\\) to the other side of the equation? The answer is no, because \\(2x\\) will never have a remainder of \\(3\\).\nWhat about \\(7x \\equiv 3 \\pmod{10}\\)? This is trickier. Let’s look at our multiples of \\(7\\): \\[\n0, 7, 14, 21, 28, 35, 42, 49, 56, 63\n\\] Ok so we see that \\(7 \\cdot 9 \\equiv 3 \\pmod {10}\\).\nThe next theorem gives the criterion for when we can “divide both sides by \\(a\\).”\nNumbers where \\(\\gcd(a, n) = 1\\) are called “coprime to \\(n\\).” They show up often when talking about modular arithmetic. We have a function, \\(\\phi(n)\\) called “Euler’s totient function” which counts the number of integers less than \\(n\\) which are coprime to \\(n\\). For example, \\(\\phi(10) = 4\\) counting \\(1, 3, 7, 9\\).\nEuler gave the following formula for \\(\\phi(n)\\) in terms of the prime factors \\(p\\) of \\(n\\): \\[\n\\phi(n) = n \\cdot \\prod_{\\substack{p \\mid n \\\\ p \\text{ prime}}} \\left(1 - \\frac1p \\right)\n\\] Here \\(p \\mid n\\) means \\(p\\) divides \\(n\\) or \\(p\\) is a factor of \\(n\\).\nThis is the form we will prove in a minute, but let us also rewrite this formula in maybe a more helpful way. Say \\(n = p_1^{k_1} \\cdots p_r^{k_r}\\) is the prime factorization of \\(n\\). Then\n\\[\n\\phi(n) = p_1^{k_1} \\cdots p_r^{k_r} \\cdot \\left( 1 - \\frac1{p_1} \\right) \\cdots \\left( 1 - \\frac1{p_r} \\right).\n\\] Now look at each pair of factors involving \\(p_i\\): \\[\np_i^{k_i} \\left( 1 - \\frac1{p_i} \\right) = p_i^{k_i} \\left( \\frac{p_i - 1}{p_i} \\right) = p_i^{k_i - 1}(p_i - 1).\n\\]\nPutting that together, we get \\[\n\\phi(n) = p_1^{k_1 - 1}(p_1 - 1) \\cdots p_r^{k_r - 1}(p_r - 1).\n\\]",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Euler's Totient Function</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/totient.html#the-totient-function",
    "href": "inclusion-exclusion/totient.html#the-totient-function",
    "title": "6  Euler’s Totient Function",
    "section": "",
    "text": "Example 6.2 For \\(n = 18 = 2 \\cdot 3^2\\) we have \\[\n\\phi(12) = 2^0(2 - 1)3^1(3 - 1) = 6.\n\\] You can double check this by listing all the numbers coprime to \\(18\\).",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Euler's Totient Function</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/totient.html#applying-inclusionexclusion",
    "href": "inclusion-exclusion/totient.html#applying-inclusionexclusion",
    "title": "6  Euler’s Totient Function",
    "section": "6.2 Applying Inclusion/Exclusion",
    "text": "6.2 Applying Inclusion/Exclusion\nFor each of the primes \\(p_i\\) which are factors of \\(n\\). Consider the property \\(P_i\\) which says that \\(a\\) is divisible by \\(p_i\\). As we’ve been doing, for a subset of these primes, we want to count the number of \\(a\\) in \\(0,\\dots,n-1\\) which are divisible by at least those primes in \\(S\\).\n\nLemma 6.1 Let \\(m\\) be a divisor of \\(n\\). The number of integers \\(a &lt; n\\) which are a multiple of \\(m\\) is \\(n / m\\).\n\n\nProof. Let’s look at an example first. Suppose \\(n = 100\\) and \\(m = 5\\). Then we list the numbers from \\(0,\\dots,99\\) and write the list mod \\(5\\). That is: \\[\n0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,\\dots,0,1,2,3,4.\n\\] Because \\(n - 1\\) is one less than \\(n\\), our last number has a remainder of one less than \\(5\\). So we see every number \\(0, 1, 2, 3, 4\\) exactly the same number of times. Since there are \\(5\\) possible remainders, we much see every remainder \\(100/5 = 20\\) times. This includes a remainder of \\(0\\).\nThis pattern works generally: we repeat remainders of \\(0, \\dots, m - 1\\) and we end on \\(m - 1\\) because \\(n - 1\\) is one less than a multiple of \\(m\\).\n\nSo putting this into our inclusion-exclusion notation, if \\(S = \\{i_1, \\dots, i_k\\}\\), then \\[\nN_\\ge(S) = \\frac{n}{p_{i_1} \\dots p_{i_k}}.\n\\]",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Euler's Totient Function</span>"
    ]
  },
  {
    "objectID": "inclusion-exclusion/totient.html#wrapping-up",
    "href": "inclusion-exclusion/totient.html#wrapping-up",
    "title": "6  Euler’s Totient Function",
    "section": "6.3 Wrapping up",
    "text": "6.3 Wrapping up\nBy Inclusion/Exclusion, the number of whole numbers \\(a &lt; n\\) not divisible by any \\(p_i\\) is \\[\nN_\\ge(\\varnothing) - \\sum_i N_\\ge(i) + \\sum_{i &lt; j} N_\\ge(i, j) - \\cdots\n\\] and that is \\[\nn - \\sum_i \\frac{n}{p_i} + \\sum_{i &lt; j} \\frac{n}{p_ip_j} - \\cdots = n \\left( 1 - \\sum_i \\frac{1}{p_i} + \\sum_{i &lt; j} \\frac{1}{p_ip_j} - \\cdots \\right).\n\\]\nWe should be able to factor a \\((1 - 1/p_1)\\) out of this so let’s work at giving that a go by separating terms including \\(p_1\\) from those that don’t: \\[\\begin{align*}\n&1 - {\\color{orange} \\sum_i \\frac{1}{p_i}} + {\\color{red} \\sum_{i &lt; j} \\frac{1}{p_ip_j}} - \\cdots \\\\\n&\\qquad = 1 - {\\color{orange}\\frac1{p_1} - \\sum_{1 &lt; i} \\frac{1}{p_i}} + {\\color{red}\\frac1{p_1} \\sum_{1 &lt; j} \\frac{1}{p_j} + \\sum_{1 &lt; i &lt; j} \\frac1{p_ip_j}} - \\cdots \\\\\n&\\qquad = \\left(1 - {\\color{orange} \\frac1{p_1}} \\right) - \\left({\\color{orange}\\frac1{p_1}\\sum_{1 &lt; i} \\frac{1}{p_i}} - {\\color{red} \\frac1{p_1} \\sum_{1 &lt; j} \\frac{1}{p_j} }\\right) + \\left({\\color{red}\\sum_{1 &lt; i &lt; j} \\frac1{p_ip_j}} - \\frac1{p_1} \\sum_{1 &lt; i &lt; j} \\frac1{p_ip_j} \\right) - \\cdots \\\\\n&\\qquad = \\left( 1 - \\frac1{p_1} \\right) \\left( 1 - \\sum_{1 &lt; i} \\frac{1}{p_i} + \\sum_{1 &lt; i &lt; j} \\frac{1}{p_ip_j} - \\cdots \\right).\n\\end{align*}\\] Note: in the second term in the second to last line, the sum over all \\(j &gt; 2\\) is the same as the sum over all \\(i &gt; 2\\) just with a different name given to the variable.\nSo we are able to factor out \\((1 - 1/p_1)\\) to get a similar expression with one fewer primes. Similarly, we can factor out \\((1 - 1/p_2)\\) and so on until there are no more primes. This gives us Euler’s product representation for the totient function.",
    "crumbs": [
      "Inclusion-Exclusion",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Euler's Totient Function</span>"
    ]
  },
  {
    "objectID": "permutations/permutations.html",
    "href": "permutations/permutations.html",
    "title": "7  Permutations",
    "section": "",
    "text": "7.1 As a shuffle of the symbols\nA permutation of a finite set \\(X\\) can be thought of in a few ways. The set of all permutations of \\(\\{1,\\dots,n\\}\\) will be denoted \\(S_n\\). This is also called the symmetric group.\nE.g. \\(53214\\) is a shuffle of \\(X = \\{1,2,3,4,5\\}\\).\nThis gives us one way of counting the number of permutations. For the first position in the shuffle, we may write any of the \\(n\\) numbers. For the second position, we have \\(n - 1\\) numbers to choose from—we cannot repeat the first. Likewise the third has \\(n - 2\\) to choose from, not repeating the first or second. In this way, the number of permutations is\n\\[\nn \\cdot (n - 1) \\cdot (n - 2) \\cdots 2 \\cdot 1, \\text{ denoted } n!.\n\\]",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Permutations</span>"
    ]
  },
  {
    "objectID": "permutations/permutations.html#sec-function",
    "href": "permutations/permutations.html#sec-function",
    "title": "7  Permutations",
    "section": "7.2 As a function from \\(X\\) to itself",
    "text": "7.2 As a function from \\(X\\) to itself\nE.g. The shuffle \\(53214\\) may be thought of as a function \\(\\pi : X \\to X\\) where \\(\\pi(i)\\) equals the \\(i\\)-th number in the shuffle:\n\\[\n\\pi(1) = 5, \\pi(2) = 3, \\pi(3) = 2, \\pi(4) = 1, \\pi(5) = 4.\n\\]\nThese functions are often represented by a table:\n\n\n\n\\(i\\)\n1\n2\n3\n4\n5\n\n\n\n\n\\(\\pi(i)\\)\n5\n3\n2\n1\n4\n\n\n\nSomething new added by the table/function representation is that we can talk about the inverse function which undoes the shuffle:\n\n\n\n\\(j = \\pi(i)\\)\n5\n3\n2\n1\n4\n\n\n\n\n\\(i = \\pi^{-1}(j)\\)\n1\n2\n3\n4\n5\n\n\n\nor reordering the columns:\n\n\n\n\\(j\\)\n1\n2\n3\n4\n5\n\n\n\n\n\\(\\pi^{-1}(j)\\)\n4\n3\n2\n5\n1\n\n\n\n\n7.2.1 Composition of functions\nGiven two permutations, \\(\\pi_1, \\pi_2 : X \\to X\\), we can compose them to get a new function \\((\\pi_1 \\circ \\pi_2)\\). One way to compute this is via the following procedure:\n\nWrite the two functions as tables.\nReorder the columns of the outermost function in the composition to align with the output of the innermost function.\nStack the tables on top of each other.\n\nE.g. Take \\(\\pi_2\\) to be the function represented by the shuffle \\(53214\\) and take \\(\\pi_1\\) to be represented by the shuffle \\(13254\\). So as a table\n\n\n\n\\(i\\)\n1\n2\n3\n4\n5\n\n\n\n\n\\(\\pi_1(i)\\)\n1\n3\n2\n5\n4\n\n\n\nNow we shuffle the columns so the top is \\(53214\\):\n\n\n\n\\(i\\)\n5\n3\n2\n1\n4\n\n\n\n\n\\(\\pi_1(i)\\)\n4\n2\n3\n1\n5\n\n\n\nThen stack this with \\(\\pi_2\\):\n\n\n\n\\(i\\)\n1\n2\n3\n4\n5\n\n\n\n\n\\(j = \\pi_2(i)\\)\n5\n3\n2\n1\n4\n\n\n\\(\\pi_1(j)\\)\n4\n2\n3\n1\n5\n\n\n\nThe bottom row is \\(\\pi_1 \\circ \\pi_2\\).\n\nExercise 7.1 Compute this in the other order: \\(\\pi_2 \\circ \\pi_1\\). Observe that the order matters.\nNote: in some sources (e.g. books, software), compositions are written as a product in the reverse order. Sometimes there is an option provided to reverse the multiplication order. Here are those computations in the SageMath computer algebra system.\n\nsage.combinat.permutation.Permutations.options(mult='r2l')\nπ1 = Permutation([1,3,2,5,4])\nπ2 = Permutation([5,3,2,1,4])\nπ1 * π2\n\n[4, 2, 3, 1, 5]\n\n\n\nπ2 * π1\n\n[5, 2, 3, 4, 1]",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Permutations</span>"
    ]
  },
  {
    "objectID": "permutations/visual.html",
    "href": "permutations/visual.html",
    "title": "8  Visual representations of permutations",
    "section": "",
    "text": "8.1 As a collection of cycles\nLet’s look at a longer permutation now: \\(541237896\\). As in Section 7.2, we can view this as a function where \\(1\\) goes to \\(5\\), \\(2\\) goes to \\(4\\) etc. Following the path of a single number we get a cycle: \\(1\\) goes to \\(5\\) goes to \\(3\\) goes to \\(1\\). Likewise \\(2\\) goes to \\(4\\) goes to \\(2\\). And so on.\nThe entire permutation can be broken up into cycles:\nπ = Permutation([5,4,1,2,3,7,8,9,6])\nπ.to_digraph().plot(vertex_size=1500)",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Visual representations of permutations</span>"
    ]
  },
  {
    "objectID": "permutations/visual.html#sec-cycle-decomposition",
    "href": "permutations/visual.html#sec-cycle-decomposition",
    "title": "8  Visual representations of permutations",
    "section": "",
    "text": "8.1.1 Notation\nThe cycle \\(1 \\to 5 \\to 3 \\to 1\\) can be written as \\((153)\\). In general, \\((a_1,\\dots,a_n)\\) represents the cycle \\(a_1 \\to a_2 \\to \\dots \\to a_n \\to a_1\\). We often omit the commas when every number is a single digit.\nHere is how to compute the cycles in SageMath:\n\nπ.cycle_string()\n\n'(1,5,3)(2,4)(6,7,8,9)'\n\n\nThe answer is given as a product (i.e. composition) of cycles.\nElements which do not go anywhere—also called fixed-points—are represented by cycles of length \\(1\\) E.g. \\((123)(4)\\) represents the two cycles \\(1 \\to 2 \\to 3 \\to 1\\) and \\(4 \\to 4\\). We often omit length \\(1\\) cycles from the notation so \\((123)(4) = (123)\\) as a permutation of \\(1,2,3,4\\).\n\nExercise 8.1 Compute the cycle decomposition for \\(341859672\\). You can verify your answer in SageMath.\nπ = Permutation([3,4,1,8,5,9,6,7,2])\nπ.cycle_string()\n\nNote: as mentioned earlier: SageMath omits the cycle \\((5)\\) representing the fixed point \\(\\pi(5) = 5\\).\n\n\n8.1.2 Multiplying Cycles\nTo multiply cycles, we read from right to left. If our current number appears in the cycle, we shift over to the right (wrapping back to the start if necessary). E.g. \\((2, 5)(1, 5, 3)\\) would move \\(1\\) to \\(5\\) with the first cycle then from \\(5\\) to \\(2\\) with the second cycle.\nYou can either do this procedure and produce a shuffle like:\n\n\n\n\\(i\\)\n1\n2\n3\n4\n5\n\n\n\n\n\\((1, 5, 3)\\)\n5\n-\n1\n-\n3\n\n\n\\((2, 5)\\)\n2\n5\n-\n-\n-\n\n\nAnswer\n2\n5\n1\n4\n3\n\n\n\nHere a “-” means the value is unchanged at this step.\nOr you can combine this with the procedure of Section 8.1 and produce a product in cycle form again. Here that is \\((1, 2, 5, 3)\\) because \\(1 \\to 5 \\to 2\\) then \\(2 \\to 5\\) then \\(5 \\to 3\\) then \\(3 \\to 1\\).",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Visual representations of permutations</span>"
    ]
  },
  {
    "objectID": "permutations/visual.html#sec-braids",
    "href": "permutations/visual.html#sec-braids",
    "title": "8  Visual representations of permutations",
    "section": "8.2 Braids",
    "text": "8.2 Braids\nAnother visual representation used frequently in the mathematical study of knots is that of crossing lines. Let’s look at an example:\n\nB.&lt;a,b&gt; = BraidGroup(3)\nplot(a * b * a)\n\n\n\n\n\n\n\n\nThis represents a permutation where the first end ends up in the third position (\\(1 \\to 3\\)), the second end ends up in the second position (\\(2 \\to 2\\)) and the third end ends up in the first position (\\(3 \\to 1\\)). Overall, \\(1\\) and \\(3\\) are swapped, so this permutation is \\((13)\\).\n\n8.2.1 Transpositions\nCycles of length \\(2\\) are called transpositions. E.g. \\((14)\\) is a transposition which switches \\(1\\) and \\(4\\). The picture above represents a composition of \\(3\\) transpositions \\((13) = (12)(23)(12)\\).\n\nTheorem 8.1 (Product of transpositions)  \n\nEvery permutation can be written as a product of transpositions\nEvery permutation can be written as a product of transpositions of adjacent elements.\n\nAnother way to say this is that by swapping pairs of elements at a time, we can obtain any possible shuffle.\n\n\nProof. We know that a permutation may be written in terms of cycles. So if we can show that any cycle can be written as a successive sequence of swaps we are good. We will give a visual demonstration of this fact:\n\nB.&lt;t1,t2,t3,t4,t5&gt; = BraidGroup(6)\nplot(t1 * t2 * t3 * t4 * t5)\n\n\n\n\n\n\n\n\nSo the cycle \\((123456) = (12)(23)(34)(45)(56)\\). Remember that compositions are read from right to left: e.g. \\((f \\circ g)(i) = f(g(i))\\) means first do \\(g\\) then do \\(f\\).\nThis kind of decomposition generalizes: you can replace \\((123456)\\) with any cycle of any length. E.g. \\((1456) = (14)(45)(56)\\):\n\nsage.combinat.permutation.Permutations.options(mult='r2l', display='cycle')\nP = Permutation\nP((1,4)) * P((4,5)) * P((5,6))\n\n(1,4,5,6)\n\n\n\nFor an alternative proof, this decomposition into a sequence of adjacent swaps is exactly how the sorting algorithm BubbleSort works. We can sort any list using BubbleSort which does only adjacent swaps. So the shuffle is obtained by reversing those swaps to go from sorted to shuffled.\n\n\n8.2.2 Braids versus permutations\nYou may have noticed in what we did, the word “braid” was used. Braids are similar to permutation except that we keep track of which strand goes above and which strand goes below. E.g. the transposition \\((12)\\) applied twice looks like\n\nB.&lt;a,b&gt; = BraidGroup(3)\nplot(a * a)\n\n\n\n\n\n\n\n\nAs a permutation this is the trivial shuffle \\(123\\). But as a braid it is still twisted.\nWhile we are only focused on permutations rather than braids here, we still make use of braids because SageMath is able to create diagrams for us.\n\n8.2.2.1 The Braid Group in SageMath\nThe generators of the braid group are adjacent swaps. So the line B.&lt;a, b&gt; = BraidGroup(3) sets a to a swap of \\(1, 2\\) and sets b to a swap of \\(2, 3\\). We can obtain the reverse swap with a^-1 or b^-1\n\nplot(a^-1 * a^-1)\n\n\n\n\n\n\n\n\nWhen converting from braids to permutations, we ignore whether a strand goes over or under and just focus on the swapping.",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Visual representations of permutations</span>"
    ]
  },
  {
    "objectID": "permutations/generators.html",
    "href": "permutations/generators.html",
    "title": "9  Generators",
    "section": "",
    "text": "9.1 Squaring relation\nIn Theorem 8.1 we saw that every cycle and hence every permutation can be written as a product of adjacent swaps: \\((12), (23), (34), \\dots, (n-1,n)\\). Here we will identify some relations that hold among these generating elements.\nLet us call \\(\\tau_i = (i, i+1)\\) the swap of \\(i\\) and \\(i + 1\\).\nWe have \\(\\tau_i^2 = 1\\) where \\(1\\) represents the identity permutation (no shuffling). This says that if we swap \\(i\\) and \\(i + 1\\) and then swap again, we get back to a sorted list.",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "permutations/generators.html#commutating",
    "href": "permutations/generators.html#commutating",
    "title": "9  Generators",
    "section": "9.2 Commutating",
    "text": "9.2 Commutating\nFrom Exercise 7.1, we saw that in general \\(\\pi_1 \\pi_2 \\neq \\pi_2 \\pi_1\\). Nonetheless, if we are swapping disjoint sets of pairs like \\((12)\\) followed by \\((34)\\) then there is no interaction between the swaps. So the order doesn’t matter: \\((12)(34) = (34)(12)\\). Specifically, \\(\\tau_i\\) and \\(\\tau_j\\) commute (\\(\\tau_i\\tau_j = \\tau_j\\tau_i\\)) provided \\(i\\) and \\(j\\) are at least \\(2\\) apart.\n\nB.&lt;a,b,c&gt; = BraidGroup(4)\nplot(a * c)\n\n\n\n\n\n\n\n\n\na * c == c * a\n\nTrue",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "permutations/generators.html#aba-bab",
    "href": "permutations/generators.html#aba-bab",
    "title": "9  Generators",
    "section": "9.3 ABA = BAB",
    "text": "9.3 ABA = BAB\nAt the top of Section 8.2 we saw that \\((12)(23)(12) = (13)\\). We also have \\((23)(12)(23) = (13)\\). Compare the following pictures.\nB.&lt;a,b&gt; = BraidGroup(3)\nplot(a * b * a)\nplot(b * a * b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can see visually that the middle green strand is sliding from one side of the blue/red crossing to the other.",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "permutations/generators.html#sec-all-relations",
    "href": "permutations/generators.html#sec-all-relations",
    "title": "9  Generators",
    "section": "9.4 Other relations?",
    "text": "9.4 Other relations?\nIt turns out, every way to simplify or manipulate products of transpositions can be reduced to exactly these three rules:\n\n\\(\\tau_i^2 = 1\\)\n\\(\\tau_i\\tau_j = \\tau_j\\tau_i\\) for \\(|i - j| \\ge 2\\) (at least two apart)\n\\(\\tau_i\\tau_{i+1}\\tau_i = \\tau_{i+1}\\tau_i\\tau_{i+1}\\)\n\nThe proof of this has two stages. One which we have already seen. First, you show that every permutation can be written as a product of transpositions of adjacent elements (Theorem 8.1). This shows that you can use \\(\\tau_1,\\dots,\\tau_n\\) and these rules to write every element of \\(S_n\\). I.e. the number of objects generated by these rules is at least \\(n!\\).\nThe second step is showing that the number of objects generated by these rules is no more than \\(n!\\) so that it is exactly the same as \\(S_n\\). This requires more tools than we have available to us (i.e. group theory). A proof for those in-the-know may be found here for instance.\nWe will take it as a fact that these rules describe \\(S_n\\) exactly.",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "permutations/sign.html",
    "href": "permutations/sign.html",
    "title": "10  Sign of a Permutation",
    "section": "",
    "text": "10.1 Step 1: reducing to the identity\nWe established in Theorem 8.1 that every permutation can be written as a product of transpositions. But more than that, in all our examples, the number of transpositions required to perform a shuffle was always consistently odd or consistently even. For instance, \\((13) = (12)(23)(12)\\) has an odd number of transpositions on both sides.\nIf we look at Section 9.4, we said that every possible way to manipulate a permutation can be reduced to three rules, each of which preserves the parity (odd or even) of the number of transpositions.\nIn case you were unsatisfied with relying on the fact that every relation reduces to the three given relations, we will present two different proofs that the parity is always consistent: one here, one in the next section.\nFor a visualization of this proof, see https://www.youtube.com/watch?v=p6kCYbKIMak starting at 13:50.\nSuppose we have two different ways to write a given permutation as a product of transpositions:\n\\[\n\\pi = \\tau_1 \\tau_2 \\dots \\tau_m = \\tau_1' \\tau_2' \\dots \\tau_n'.\n\\]\n(Here the letter \\(\\tau\\) means any transposition, not just for adjacent elements.)\nOur goal is to show that \\(m\\) and \\(n\\) have the same parity (both are odd or both are even). Notice that if we multiply both sides by \\(\\tau_1\\), we get\n\\[\n\\tau_1 \\cdot \\tau_1 \\tau_2 \\dots \\tau_m = \\tau_1 \\cdot \\tau_1' \\tau_2' \\dots \\tau_n'\n\\]\nbut \\(\\tau_1 \\cdot \\tau_1\\) means swap the same pair twice, and doing this twice is the same as not doing it at all. Therefore the \\(\\tau_1 \\cdot \\tau_1\\) cancels and we are left with\n\\[\n\\tau_2 \\dots \\tau_m = \\tau_1 \\cdot \\tau_1' \\tau_2' \\dots \\tau_n'.\n\\]\nKeep doing this from left to right until we have\n\\[\n1 = \\tau_m \\dots \\tau_2 \\tau_1 \\tau_1' \\tau_2' \\dots \\tau_n'.\n\\]\nSo saying “\\(m\\) and \\(n\\) have the same parity” is equivalent to saying “\\(1\\) cannot be written as an odd number of transpositions.”",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Sign of a Permutation</span>"
    ]
  },
  {
    "objectID": "permutations/sign.html#step-2-setting-up-the-induction-hypothesis",
    "href": "permutations/sign.html#step-2-setting-up-the-induction-hypothesis",
    "title": "10  Sign of a Permutation",
    "section": "10.2 Step 2: setting up the induction hypothesis",
    "text": "10.2 Step 2: setting up the induction hypothesis\nLet’s introduce some letters now for our transpositions. Say\n\\[\n1 = (a_1b_1)(a_2b_2) \\cdots (a_kb_k)\n\\tag{10.1}\\]\nwhere \\(a_i \\neq b_i\\) for all \\(i\\) (we’re always swapping two different things).\nWe know that \\(k\\) isn’t \\(1\\) since a single transposition is not the same as the identity. So look now at \\(k \\ge 2\\). We will show that we can always rewrite this product using \\(k - 2\\) transpositions.\nThere are a couple ways to phrase this next part of the proof. First, we could say: take as an inductive hypothesis that for all \\(k' &lt; k\\) if the identity is written as a product of \\(k'\\) transpositions then \\(k'\\) is even. In this way, going from \\(k\\) to \\(k' = k - 2\\) we know that \\(k - 2\\) is even and hence so is \\(k\\).\nAnother way we could say this: we are always reducing by \\(2\\) every time so \\(k - 2 - 2 - 2 - \\dots\\) will either end up at \\(0\\) or \\(1\\) and we know it can’t end up at \\(1\\).",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Sign of a Permutation</span>"
    ]
  },
  {
    "objectID": "permutations/sign.html#step-3-reorganizing-the-product",
    "href": "permutations/sign.html#step-3-reorganizing-the-product",
    "title": "10  Sign of a Permutation",
    "section": "10.3 Step 3: reorganizing the product",
    "text": "10.3 Step 3: reorganizing the product\nLook back at Equation 10.1. Since \\((ab) = (ba)\\), to keep things consistent, we will assume that \\(a_i &lt; b_i\\) always. Let \\(a\\) be the smallest number appearing in any transposition. E.g. for \\((23)(34)(23)(24)\\) we have \\(a = 2\\).\nWe will slide all the the transpositions with an \\(a\\) in them to the right (towards the beginning of the composition). Now we can’t just move things without changing the product so we have to be strategic.\nLet’s say we have in the middle of our expression \\((uv)(xy)\\) where \\(u = a\\) and \\(x \\neq a\\) and so we want to move \\((uv)\\) to the right of \\((xy)\\).\n\n10.3.1 Case 1: disjoint\nIf \\(u, v, x, y\\) are all distinct, then the two swaps can be done in either order and \\((uv)(xy) = (xy)(uv)\\).\n\n\n\n\n\n\n\n\n\n\n\n10.3.2 Case 2: two numbers in common\nIf \\((uv) = (xy)\\) then \\((uv)(xy) = (uv)^2 = 1\\) and we have reduced the number of transpositions by \\(2\\) as we said we would.\n\n\n10.3.3 Case 3: larger number in common\nConsider the product \\((12)(23) = (123)\\) (swap \\(2,3\\) first then \\(1,2\\))\n\n\n\n\n\n\n\n\n\nCompare this with the identity \\((23)(12)(23) = (13)\\) that we worked out in Chapter 9:\n\n\n\n\n\n\n\n\n\nMultiply both sides on the left by \\((23)\\) and simplify using \\((23)(23) = 1\\) to get \\((12)(23) = (23)(13)\\).\nIn this way, the smallest number is always moving to the right. The rule is \\((uv)(xy) = (xy)(uv')\\) where \\(v'\\) is the number in \\((xy)\\) which wasn’t in common.\n\nExercise 10.1 Work out the diagrams to show that \\((12)(23) = (23)(13)\\). (I would show you in SageMath, but the software doesn’t draw \\((13)\\) very well.)\n\n\n\n10.3.4 Case 4: smaller number in common\nUsing the previous case, we move all the terms having \\(u = a\\) to the right. So now we have a bunch of terms \\((av_1)(av_2) \\dots (av_r)\\) in the right of our product. We know we have at least two pairs because if we swap \\(a\\) out of position, something later on has to swap it back into position.\nAlso, if any of the adjacent pairs are equal, we can cancel them as in Case 2. Otherwise, we do something similar to Case 3 where\n\\[\n(12)(23)(12) = (13) \\implies (12)(23) = (13)(12)\n\\]\nby multiplying on the right by \\((12)\\)\nThe feature of this identity is that we have one fewer \\(1\\)’s, or more generally, one fewer \\(a\\)’s. And we can keep doing this until we are left with either a single \\(a\\) (impossible) or we eventually find a pair that cancels.\n\nExercise 10.2 Draw the diagram for this identity.",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Sign of a Permutation</span>"
    ]
  },
  {
    "objectID": "permutations/sign.html#summary",
    "href": "permutations/sign.html#summary",
    "title": "10  Sign of a Permutation",
    "section": "10.4 Summary",
    "text": "10.4 Summary\nWe showed that we can push all the transpositions containing a \\(1\\) to the right and then moving those transpositions past each other until we had fewer and fewer \\(1\\)’s and eventually there must be a pair with both numbers in common because we can’t just move \\(1\\) a single time in our sequence of transpositions.\n\nExample 10.1 Start with \\((12)(23)(12)(13)\\). Use Case 3 to swap the first and second: \\((23)(13)(12)(13)\\). Now use Case 4 to swap the second and third: \\((23)(23)(13)(13)\\). Now cancel using Case 2.",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Sign of a Permutation</span>"
    ]
  },
  {
    "objectID": "permutations/sign.html#sec-sign-algorithm",
    "href": "permutations/sign.html#sec-sign-algorithm",
    "title": "10  Sign of a Permutation",
    "section": "10.5 Notation/Computation",
    "text": "10.5 Notation/Computation\nIf \\(\\pi\\) is a permutation, common notations for its parity or sign are: \\(\\operatorname{sgn} \\pi\\) and \\((-1)^\\pi\\). We say the sign is \\(+1\\) if it is an even length product and the sign is \\(-1\\) if it is an odd length product.\nWe have the identity \\(\\operatorname{sgn}(\\pi_1 \\pi_2) = \\operatorname{sgn}\\pi_1 \\operatorname{sgn} \\pi_2\\) because, for example, multiplying two odd length products creates an even length product (\\((-1) \\cdot (-1) = +1\\))\nOne way to compute this is by decomposing \\(\\pi\\) into cycles. We saw in Theorem 8.1 how to write cycles in terms of transpositions: \\((12345) = (12)(23)(34)(45)\\). The observation here is that odd length cycles become an even length product of transpositions and vice versa.\nSo the algorithm is:\n\nConvert the permutation into a product of cycles.\nWrite a \\(+1\\) if the cycle has an odd length and a \\(-1\\) if it has an even length.\nMultiply those numbers together to find the sign.\n\n\nExample 10.2 Consider the shuffle \\(376819254\\). We can write this as \\((1369485)(27)\\) this is a product of a cycle of length \\(7\\) and a cycle of length \\(2\\). Therefore the sign is \\((+1)(-1) = -1\\).\nThis computation in SageMath:\n\nπ = Permutation([3,7,6,8,1,9,2,5,4])\nsign(π)\n\n-1",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Sign of a Permutation</span>"
    ]
  },
  {
    "objectID": "permutations/inversions.html",
    "href": "permutations/inversions.html",
    "title": "11  Inversions",
    "section": "",
    "text": "11.1 Parity of the number of inversions\nWe present a second (or third depending if you count the proof we didn’t prove) proof that the number of transpositions is always ever even or always odd.\nLet \\(\\pi\\) be a permutation. An inversion for \\(\\pi\\) is a pair of outputs which are not in sorted order. I.e. we have \\(i &lt; j\\) to begin with and \\(\\pi(i) &gt; \\pi(j)\\) to end with.\nIn counting inversions, we look at where \\(\\pi(i)\\) is greater than \\(\\pi(j)\\) for some \\(j\\) that comes after \\(i\\).\nInversions as a concept have a few uses in combinatorics. Relevant to us now is that the number of inversions has the same parity as the permutation. To show this, we will consider how a single transposition affects this parity. But since the total number can go up or down, let us define a quantity which we can analyze to describe the parity.\nFor the identity permutation, define \\[\nV(1) = \\prod_{i &lt; j} (j - i)\n\\]\nE.g. for \\(n = 4\\) this is \\((2 - 1)(3 - 1)(4 - 1)(3 - 2)(4 - 2)(4 - 3)\\). We’re not interested in the absolute value here but rather the sign—which for the identity permutation is \\(+1\\).\nMore generally, define \\[\nV(\\pi) = \\prod_{i &lt; j}(\\pi(j) - \\pi(i)).\n\\]\nNote that we will have a factor of \\(V(\\pi)\\) which is negative whenever \\(i &lt; j\\) and \\(\\pi(i) &gt; \\pi(j)\\). So the sign of \\(V(\\pi)\\) tells us the parity of the number of inversions.\nWhat’s useful here is that factoring out the various \\(-1\\)’s and reordering, we can write \\(V(\\pi) = \\pm V(1)\\) where it is a \\(+1\\) if we have an even number of inversions and a \\(-1\\) if we have an odd number.",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Inversions</span>"
    ]
  },
  {
    "objectID": "permutations/inversions.html#analysis",
    "href": "permutations/inversions.html#analysis",
    "title": "11  Inversions",
    "section": "11.2 Analysis",
    "text": "11.2 Analysis\nWe want to show that a single transposition changes \\(V(1)\\) to \\(-V(1)\\). Then a sequence of odd length will have a sign of \\(-1\\) and one of even length will have a sign of \\(+1\\), matching what we did in Chapter 10.\nSuppose we apply the transposition \\((ij)\\) with \\(i &lt; j\\). Right away, we get one inversion because now \\(\\pi(i) &gt; \\pi(j)\\). Let’s look at the other numbers. Suppose \\(x &lt; i &lt; j\\). Then after swapping, we still have \\(x\\) on the left of \\(i,j\\)$ so no inversions here. Likewise, if \\(i &lt; j &lt; x\\) then \\(x\\) will still be on the right afterwards.\nThe last case is that \\(i &lt; x &lt; j\\). Then we get two inversions going from \\(i,x,j\\) to \\(j,x,i\\). One between \\(i\\) and \\(x\\) and one between \\(x\\) and \\(j\\) since both these pairs are now out of order.\nTo summarize, this single transposition gives us:\n\n\\(0\\) inversions for anything left of \\(i\\) or right of \\(j\\),\n\\(2\\) inversions for each number in between,\n\\(1\\) inversion for the pair \\(i, j\\)\n\nSo overall we get an odd number of inversions for each swap. This shows that the number of inversions is odd if and only if the number of swaps is odd.",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Inversions</span>"
    ]
  },
  {
    "objectID": "permutations/permutation-exercises.html",
    "href": "permutations/permutation-exercises.html",
    "title": "12  Exercises",
    "section": "",
    "text": "Convert \\(2, 12, 3, 5, 4, 9, 8, 7, 6, 10, 1, 11\\) to a product of cycles and draw the associated digraph.\n\n\n\n\n\n  \n    \n      \n        \n    \n\n    \n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\nReference: Section 8.1\n\nstart with 1\n\nthere is a 2 in position 1\nthere is a 12 in position 2\nkeep going…x in position 12…until you get back to 1\n\nwrite down the first cycle \\((1, 2, 12, \\dots)\\) (don’t repeat the \\(1\\) at the end)\ndo the same procedure with the next number which hasn’t been seen so far (i.e. 3)\nkeep going until every number is part of a cycle\noptionally, throw away cycles of length 1\n\n\n\n\n\nConvert \\((1,8,12)(2,3,6,7,9)(4,10,11)\\) to a shuffle of \\(1,\\dots,12\\)\n\n\n\n\n\n  \n    \n      \n        \n    \n\n    \n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\nReference: Section 8.1.2\nSince the cycles are disjoint (don’t share any numbers), the procedure here is:\n\nlook for each number from 1 to 12\nwrite down the number following it in its cycle (e.g. 1 is followed by 8 so we write an 8 in the first position of the shuffle, 2 is followed by 3, 3 by 6, etc.)\nif a number does not appear (i.e. 5), then the permutation leaves it unchanged and it remains in its starting position (so you should have a 5 in position 5 at the end)\n\n\n\n\n\nShow that \\((12)(23)(34)(23)(12) = (14)\\) by drawing the braid diagram.\nCompute the sign of the permutations in 1. and 2.\n\n\n\n\n\n\n\n  \n    \n      \n        \n    Problem 1:   \n     Choose...\n     -1 \n\n     1 \n\n  \nMake a selection\n \n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    Problem 2:   \n     Choose...\n     1 \n\n     -1 \n\n  \nMake a selection\n \n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\nReference: Section 10.5\nRegardless of whether the cycles are disjoint or not (here they are), odd cycles are even and even cycles are odd (in terms of number of swaps). So multiply \\(1\\) for each odd length cycle and \\(-1\\) for each even length cycle. For example, \\((1, 8, 2)\\) has an odd length (even number of swaps) so we multiply \\(+1\\) for it.\n\n\n\n\nWrite \\((182635)\\) as a product of transpositions.\n\n\n\n\n\n  \n    \n      \n        \n    \n\n    \n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\nReference: Theorem 8.1\nThe rule is like \\((a,b,c,d) = (a, b)(b, c)(c, d)\\). The transpositions are adjacent pairs.\n\n\n\n\nAdditional practice\n\nShuffle to CyclesCycles to ShufflesSignTranspositions\n\n\n\nn:    \n\n\n\n\n\n  \n    \n      \n        \n    \n\n    \n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n\nn:    \n\n\n\n\n\n  \n    \n      \n        \n    \n\n    \n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n\nn:    \n\n\n\n\n\n  \n    \n      \n        \n    \n\n    \n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n\nn:    \n\n\n\n\n\n  \n    \n      \n        \n    \n\n    \n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n\n\n\nSolutions\n\n\n(1, 2, 12, 11)(4, 5)(6, 9)(7, 8)\n\n\n\n8, 3, 6, 10, 5, 7, 9, 12, 2, 11, 4, 1\n\nboth even (+1)\n(1, 8)(8, 2)(2, 6)(6, 3)(3, 5)",
    "crumbs": [
      "Permutations",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "generating-functions/weights.html",
    "href": "generating-functions/weights.html",
    "title": "13  Weight Functions",
    "section": "",
    "text": "13.1 Recap: Strings\nRecall that an alphabet is a set of characters like \\(\\{0, 1\\}\\) is the alphabet for binary. A string is an ordered sequence of characters from a fixed alphabet. E.g. \\(011011\\) and \\(00011\\) are binary strings.\nAdditionally, \\(\\varepsilon\\) will denote the empty string and multiplication of strings will be done by concatenation. E.g. \\(011 \\cdot 000 = 011000\\).\nFor most examples that follow, we will work with binary strings of \\(0\\)s and \\(1\\)s unless otherwise specified.",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Weight Functions</span>"
    ]
  },
  {
    "objectID": "generating-functions/weights.html#definition",
    "href": "generating-functions/weights.html#definition",
    "title": "13  Weight Functions",
    "section": "13.2 Definition",
    "text": "13.2 Definition\nLet \\(S\\) be a set of strings (e.g. all binary strings or all ternary strings). A weight function on \\(S\\) is a function \\(f : S \\to \\mathbf{Z}\\) satisfying:\n\n\\(f(x) \\ge 0\\)\n\\(f(uv) = f(u) + f(v)\\) when \\(u\\) and \\(v\\) are two strings.\n\n\nExample 13.1 The length \\(l\\) of a string is a weight. E.g. \\(l(011) = 3, l(011 \\cdot 10011) = l(011) + l(10011)\\).\n\n\nExample 13.2 \\(f(s) =\\) the number of \\(1\\)s in \\(s\\) is a weight. E.g. \\(f(011) = 2\\) and \\(f(011 \\cdot 10011) = f(011) + l(10011)\\).\n\n\n13.2.1 Key property\nThe definition of a weight means they behave kind of like a logarithm. Therefore, if we do \\(x^{f(s)}\\), we get a function which satisfies\n\\[\nx^{f(uv)} = x^{f(u)} \\cdot x^{f(v)}.\n\\] This is why we are going to have a bunch of \\(x\\)s all over the next few sections.",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Weight Functions</span>"
    ]
  },
  {
    "objectID": "generating-functions/ogf.html",
    "href": "generating-functions/ogf.html",
    "title": "14  Generating Functions",
    "section": "",
    "text": "14.1 Definition\nLet \\(L\\) be a subset of strings. These is also called a language. Let \\(f\\) be a weight function. We define the (ordinary) generating function of \\(L\\) or OGF as\n\\[\n\\Phi_L(x) = \\Phi_L^f(x) = \\sum_{s \\in L} x^{f(s)}.\n\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Generating Functions</span>"
    ]
  },
  {
    "objectID": "generating-functions/ogf.html#definition",
    "href": "generating-functions/ogf.html#definition",
    "title": "14  Generating Functions",
    "section": "",
    "text": "Note\n\n\n\nIt is common in mathematical definitions to write something like \\[\n\\Phi_L(x) = \\Phi_L^f(x) = \\cdots.\n\\] This means that I am calling attention to the fact that \\(\\Phi\\) depends on \\(f\\) but also saying that because \\(f\\) isn’t going to change much, we are going to drop the \\(f\\) from the notation most or all of the time.\nIt is also common to call generating functions by other letters, like \\(A(x)\\) but this needs to be introduced first by saying that \\(A\\) is the OGF wheras \\(\\Phi_L\\) means this implicitly.\n\n\n\nExample 14.1 Let \\(L\\) be the subset \\(\\{01, 1110, 11, 0, 1, 111000, \\varepsilon\\}\\) of binary strings. Let \\(f\\) be the length weight. The OGF of \\(L\\) is \\[\\begin{align*}\n\\Phi_L(x) &= x^{f(01)} + x^{f(1110)} + x^{f(11)} + x^{f(0)} + x^{f(1)} + x^{f(111000)} + x^{f(\\varepsilon)} \\\\\n&= x^2 + x^4 + x^2 + x^1 + x^1 + x^6 + x^0 \\\\\n&= 1 + 2x + 2x^2 + x^4 + x^6\n\\end{align*}\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Generating Functions</span>"
    ]
  },
  {
    "objectID": "generating-functions/ogf.html#monomials",
    "href": "generating-functions/ogf.html#monomials",
    "title": "14  Generating Functions",
    "section": "14.2 Monomials",
    "text": "14.2 Monomials\nInside \\(\\Phi_L(x)\\), each monomial \\(a_nx^n\\) (after collecting terms) represents that \\(L\\) has \\(a_n\\) strings where \\(f\\) equals \\(n\\) (e.g. the length equals \\(n\\)).\n\nExample 14.2 For the language \\(L\\) of Example 14.1 above, we have for instance, \\(2\\) strings of legnth \\(1\\), represented by the monomial \\(2x^1\\). We have \\(1\\) string of length \\(6\\) represented by the monomial \\(1x^6\\). We have no strings of length \\(5\\), represented by the lack of a monomial with \\(x^5\\). We could also say that the coefficient of \\(x^5\\) is \\(0\\).\n\n\nExercise 14.1 Let \\(L\\) be the set of all binary strings of length \\(\\le 5\\) which have no \\(11\\).\n\nfor \\(n = 0, 1, 2, 3, 4, 5\\), list all the strings with no \\(11\\)\nwrite down the generating function with respect to the length weight\nwrite down the generating function with respect to the “number of 1s” weight\n\n\n\n14.2.1 Using generating functions to count\nThe monomials \\(a_nx^n\\) are created by adding up all the words in \\(L\\) of weight \\(n\\). So another way to describe the generating function is \\[\n\\Phi_L(x) = \\sum_{s \\in L} x^{f(s)} = \\sum_{n = 0}^\\infty \\#\\{s \\in L : f(s) = n\\} x^n.\n\\tag{14.1}\\] This means the general strategy for getting an answer from a generating function is to—by some process—write it as as a power series \\(\\sum a_n x^n\\) making sure that it’s \\(x^n\\). Then \\(a_n\\) is the answer to the question: how many strings of weight \\(n\\) are there where (whatever conditions we set).\n\nTheorem 14.1 (Addition Theorem) If \\(L\\) and \\(L'\\) are disjoint, then \\(\\Phi_{L \\cup L'}(x) = \\Phi_{L}(x) + \\Phi_{L'}(x)\\).\n\n\nProof. To say that \\(L\\) and \\(L'\\) are disjoint implies that \\[\n\\#\\{s \\in L \\cup L' : f(s) = n\\} = \\#\\{s \\in L : f(s) = n\\} + \\#\\{s \\in L' : f(s) = n\\}.\n\\] Substituting this into Equation 14.1 yields \\[\\begin{align*}\n\\Phi_{L \\cup L'}(x) &= \\sum_{n = 0}^\\infty \\#\\{s \\in L : f(s) = n\\} x^n + \\sum_{n = 0}^\\infty \\#\\{s \\in L' : f(s) = n\\} x^n \\\\\n&= \\Phi_{L}(x) + \\Phi_{L'}(x).\n\\end{align*}\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Generating Functions</span>"
    ]
  },
  {
    "objectID": "generating-functions/ogf.html#sec-geom-series",
    "href": "generating-functions/ogf.html#sec-geom-series",
    "title": "14  Generating Functions",
    "section": "14.3 Infinite series",
    "text": "14.3 Infinite series\nWe’ve looked at examples where \\(L\\) is a finite set. In many examples, \\(L\\) will be an infinite set. For instance consider the infinite set of all strings of \\(0\\)s. I.e. \\(\\{\\varepsilon, 0, 00, 000, 0000, \\dots\\}\\). For this language, we have the generating function \\[\nA = 1 + x + x^2 + x^3 + \\cdots = \\frac{1}{1 - x}.\n\\]\n\n\n\n\n\n\nTipGeometric series formula\n\n\n\n\n\nTo prove this formula, we take \\(A\\) and multiply everything by \\(x\\) because that creates a lot of similar terms: \\[\\begin{align*}\nA  &= 1 + x + x^2 + x^3 + \\cdots \\\\\nxA &= \\phantom{1+{}}x + x^2 + x^3 + \\cdots \\\\\nA - xA &= 1\n\\end{align*}\\] From which we solve for \\(A = \\dfrac{1}{1 - x}\\).\n\n\n\n\nExample 14.3 Let \\(L\\) is the language of all binary strings, i.e. \\(L = \\{\\varnothing, 0, 1, 00, 01, 10, 11, 000, \\dots\\}\\). We know that there are \\(2^n\\) binary strings of length \\(n\\) so the OGF of \\(L\\) is \\[\n\\Phi_L(x) = \\sum_{n = 0}^\\infty 2^nx^n = \\sum_{n = 0}^\\infty (2x)^n = \\frac{1}{1 - 2x}.\n\\]\n\n\n\n\n\n\n\nNote\n\n\n\nIn a calculus or analysis course, we would want to specify here that \\(|x| &lt; \\frac12\\) for this series to converge. In combinatorics, we treat these series purely algebraically. That means as an infinite list of monomials without care whether or not the series converges. People use the term formal power series to refer to this concept.\n\n\n\n14.3.1 When do we care about convergence?\nFor the most part, we don’t. Meaning an infinite series is still valid even if it doesn’t converge other than when \\(x = 0\\). However, there are arguements using analysis which only apply to convergent power series. For instance, the fact that the series \\[\n1 + x + 2x^2 + 3x^3 + 5x^4 + 8x^5 + \\cdots = \\frac{1}{1 - x - x^2}\n\\] converges for \\(|x| &lt; \\frac{1}{\\phi}\\) where \\(\\varphi = \\frac{1 + \\sqrt5}{2}\\) is connected to the fact that the Fibonnaci numbers are approximately \\(c \\varphi^n\\) for some constant \\(c\\).\n\nExercise 14.2 In fact, one can show that \\[\n\\mathrm{Fib}_n = \\operatorname{round}\\left( \\frac{\\varphi^n}{\\sqrt 5} \\right).\n\\] Use a calculator or a computer to check this works!",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Generating Functions</span>"
    ]
  },
  {
    "objectID": "generating-functions/multiplication.html",
    "href": "generating-functions/multiplication.html",
    "title": "15  Multiplication of Generating Functions",
    "section": "",
    "text": "15.1 Multiplication of Monomials\nSuppose \\(L, L'\\) are two languages. We define the concatenated language \\(LL'\\) by concatenating a string from \\(L\\) and a string from \\(L'\\) in all possible ways:\n\\[\nLL' = \\{uv : u \\in L, v \\in L'\\}.\n\\]\nThe utility of this is that many common languages of strings can be written as concatenations of smaller, more simpler languages. And, it will turn out, we can compute the OGF of the more complex language out of the OGFs for the simpler languages.\nSuppose we have a language \\(L\\) which consists of \\(10\\) strings, each of length \\(5\\). Suppose we also have a language \\(L'\\) consisting of \\(6\\) strings, each of length \\(7\\). Concatenating any pair of strings will always yield a string of length \\(12\\) and there are \\(60\\) such pairs. This computation is represented by the following multiplication of generating functions: \\[\n(10x^5) \\cdot (6x^7) = 60x^{12}.\n\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Multiplication of Generating Functions</span>"
    ]
  },
  {
    "objectID": "generating-functions/multiplication.html#a-step-further",
    "href": "generating-functions/multiplication.html#a-step-further",
    "title": "15  Multiplication of Generating Functions",
    "section": "15.2 A step further",
    "text": "15.2 A step further\nNow suppose \\(L\\) is the same as before: \\(10\\) strings of length \\(5\\), and this time \\(L'\\) consists of \\(3\\) strings of length \\(4\\) and \\(7\\) strings of length \\(8\\). Now if we concatenate to form \\(LL'\\) we are either combining a string of length \\(5\\) with one of length \\(4\\) (in \\(10 \\cdot 3\\) ways) or a string of length \\(5\\) with one of length \\(8\\) (in \\(10 \\cdot 7\\) ways). Again, this computation is reflected in the product of polynomials \\[\n10x^5 \\cdot (3x^4 + 7x^8) = 30x^9 + 70x^{13}.\n\\]\n\nExercise 15.1 Suppose \\(L\\) consists of \\(3\\) strings of length \\(4\\) and \\(8\\) of length \\(6\\). Suppose \\(L'\\) consists of \\(2\\) strings of length \\(1\\) and \\(5\\) strings of length \\(4\\). What will \\(LL'\\) consist of?",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Multiplication of Generating Functions</span>"
    ]
  },
  {
    "objectID": "generating-functions/multiplication.html#multiplication-theorem",
    "href": "generating-functions/multiplication.html#multiplication-theorem",
    "title": "15  Multiplication of Generating Functions",
    "section": "15.3 Multiplication theorem",
    "text": "15.3 Multiplication theorem\n\nTheorem 15.1 (Multiplication Theorem) Let \\(L\\) and \\(L'\\) be two different languages. Let \\(f\\) be a common weight function like the length of a string. Then \\[\n\\Phi_{LL'}(x) = \\Phi_L(x)\\Phi_{L'}(x).\n\\]\n\n\nProof. We have \\[\\begin{align*}\n\\Phi_{LL'}(x) &= \\sum_{w \\in LL'} x^{f(w)} \\\\\n&= \\sum_{u \\in L} \\sum_{v \\in L'} x^{f(uv)} \\\\\n&= \\sum_{u \\in L} \\sum_{v \\in L'} x^{f(u)}x^{f(v)}\n\\end{align*}\\] using Section 13.2.1. Continuing, we get \\[\\begin{align*}\n\\phantom{\\Phi_{LL'}(x)} &= \\sum_{u \\in L} x^{f(u)} \\sum_{v \\in L'} x^{f(v)} \\\\\n&= \\Phi_L(x) \\Phi_{L'}(x).\n\\end{align*}\\]\n\n\n\n\n\n\n\nTip\n\n\n\nOne might wonder whether \\(\\sum a_i \\sum b_j\\) means \\((\\sum a_i)(\\sum b_j)\\) or \\(\\sum \\left(a_i \\sum b_j \\right)\\). It turns out these are the same, and it is explained by the distributive property of multiplication. For example, \\[\n(a_1 + a_2 + a_3)(b_1 + b_2) = a_1(b_1 + b_2) + a_2(b_1 + b_2) + a_3(b_1 + b_2).\n\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Multiplication of Generating Functions</span>"
    ]
  },
  {
    "objectID": "generating-functions/multiplication.html#sec-0s-then-1s",
    "href": "generating-functions/multiplication.html#sec-0s-then-1s",
    "title": "15  Multiplication of Generating Functions",
    "section": "15.4 Strings with 0s followed by 1s",
    "text": "15.4 Strings with 0s followed by 1s\nLet \\(L\\) be the language of strings with only \\(0\\)s and let \\(L'\\) be the language of strings with only \\(1\\)s. In Section 14.3, we saw that these languages have generating functions \\(\\frac{1}{1 - x}\\) (weighting by length). By theorem Theorem 15.1, the language \\(LL'\\) of all strings of \\(0\\)s followed by \\(1\\)s has generating function \\[\n\\frac{1}{(1 - x)^2}.\n\\]\nWe can compute this in a couple ways. First, we ask the question: “how many strings are there of length \\(n\\) consisting of a string of \\(0\\)s followed by a string of \\(1\\)s?” E.g. for \\(n = 4\\) there are \\(5\\) such strings: \\[\n0000, 0001, 0011, 0111, 1111.\n\\] We can look at this as: there are either \\(0, 1, 2, 3, 4\\) ones. In general, there will be \\(n + 1\\) strings of length \\(n\\) (corresponding to the monomial \\((n + 1)x^n\\)). Therefore \\[\n\\frac{1}{(1 - x)^2} = \\sum_{n = 0}^\\infty (n + 1)x^n = 1 + 2x + 3x^2 + 4x^3 + \\cdots.\n\\]\n\n15.4.1 Calculus?\nThe monomials we’ve just computed look suspiciously like derivatives: \\(1\\) is the derivative of \\(x\\), \\(2x\\) is the derivative of \\(x^2\\), \\(3x^2\\) is the derivative of \\(x^3\\), and so on. I.e., we have \\[\n\\frac{1}{(1 - x)^2} = \\sum_{n = 0}^\\infty \\frac{d}{dx} x^n.\n\\]\n\n\n\n\n\n\nTip\n\n\n\nThe sums \\(\\sum nx^{n-1}\\) and \\(\\sum (n + 1)x^n\\) are equal. In words: each sum is adding up all monomials whose coefficient is exactly \\(1\\) more than the exponent. Algebraically, we can transform the first sum to the second by letting \\(m = n - 1\\) and \\(n = m + 1\\). Then \\[\n\\sum nx^{n-1} = \\sum (m + 1)x^m.\n\\] When working with OGFs, we often want to make such tranformations so that the question of “how many strings of length \\(n\\)” can be read directly from the summand \\(a_nx^n\\): there are \\(a_n\\) strings of length \\(n\\).\n\n\nIn our calculus courses, we learn that we can often take the derivative of a series term-by-term. Or in other words, we can safely move the derivative operator from inside the term to outside and vice versa: \\[\n\\sum_{n = 0}^\\infty \\frac{d}{dx} x^n = \\frac{d}{dx} \\sum_{n = 0}^\\infty \\sum_{n = 0}^\\infty x^n.\n\\] This we recognize as the geometric series from Section 14.3. So that means we should expect \\[\n\\frac{1}{(1 - x)^2} = \\frac{d}{dx} \\frac{1}{1-x}.\n\\] Indeed, that is the case.\nThe following is a result of analysis that is very potent for many OGF problems.\n\nTheorem 15.2 If \\(\\sum a_n x^n\\) converges to a function \\(f(x)\\) (and the radius of convergence is not zero), then \\[\n\\sum \\frac{d}{dx} a_n x^n = f'(x)\n\\] (and the radius of convergence is preserved).\n\nIn Section 14.3.1, we said that these generating functions are still valid even when they don’t converge. But there is utility here in that if we have an expression to represent an infinite sum like how \\(\\frac{1}{1-x}\\) represents the geometric series, then we can compute the derivative of the expression and of the infinite series.\n\nExample 15.1 Given that \\[\n\\frac{1}{(1 - x)^2} = 1 + 2x + 3x^2 + 4x^3 + \\dots = \\sum nx^{n-1},\n\\] we can compute the derivative on both sides to obtain \\[\n\\frac{2}{(1 - x)^3} = 2 + 6x + 12x^2 + 20x^3 + \\cdots = \\sum n(n-1)x^{n-2}.\n\\] If we divide by \\(2\\) we might recognize this as \\[\n\\frac{1}{(1 - x)^3} = \\sum \\frac{n(n-1)}{2}x^{n-2} = \\sum \\binom{n}2x^{n - 2}\n= \\sum \\binom{n + 2}{2} x^n.\n\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Multiplication of Generating Functions</span>"
    ]
  },
  {
    "objectID": "generating-functions/stars-and-bars-revisited.html",
    "href": "generating-functions/stars-and-bars-revisited.html",
    "title": "16  Stars and Bars Revisited",
    "section": "",
    "text": "16.1 From 2 people to k people\nSuppose we have \\(2\\) people and \\(n\\) identical objects to distribute. Let’s say for now that a person gets \\(0\\) or more objects but all \\(n\\) objects are distributed. An example arrangement we might create with stars and bars would look like \\[\n*****\\mid***.\n\\] The key insight is that if we change this to \\[\n0\\,0\\,0\\,0\\,0\\mid1\\,1\\,1.\n\\] Now it looks like the problem we studied in Section 15.4. The bar here is no longer necessary to know where the first group ends and the second begins.\nNow we can check that our stars-and-bars formula agrees with the formula computed in Section 15.4. Indeed, that formula is \\[\n\\binom{n + 1}{1} = n + 1.\n\\]\nLet’s copy the key insight for the \\(k = 2\\) case. A distribution of \\(n\\) objects to \\(k\\) people, with each receiving \\(0\\) or more, looks like a string \\[\n1\\cdots12\\cdots23\\cdots3\\cdots\\cdots k\\cdots k.\n\\] Here the number of \\(i\\)s in the string is the number of objects person \\(i\\) receives. E.g. \\[\n1122223555\n\\] means person \\(1\\) receives \\(2\\) objects, person \\(2\\) receives \\(4\\), person \\(3\\) receives \\(1\\), person \\(5\\) receives \\(3\\), and everyone else (including person \\(4\\)) receives none.",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Stars and Bars Revisited</span>"
    ]
  },
  {
    "objectID": "generating-functions/stars-and-bars-revisited.html#from-2-people-to-k-people",
    "href": "generating-functions/stars-and-bars-revisited.html#from-2-people-to-k-people",
    "title": "16  Stars and Bars Revisited",
    "section": "",
    "text": "16.1.1 Applying the multiplication theorem\nLet \\(L_i\\) be the language of strings consisting of \\(0\\) or more of the character \\(i\\). Then the stars-and-bars language for \\(k\\) people, is \\(L_1 L_2 \\cdots L_k\\). We also know from Section 14.3 that each of these language has a generating function of \\(\\frac{1}{1-x}\\). It follows that our stars-and-bars language has a generating function of \\[\n\\frac{1}{(1 - x)^k} = \\sum_{n = 0}^\\infty \\binom{n + k - 1}{k - 1} x^n.\n\\] We know these are the coefficients because we know there are \\(\\binom{n + k - 1}{k - 1}\\) stars-and-bars strings of length \\(n\\) (i.e. that many ways to distribute the \\(n\\) objects among \\(k\\) people).\n\nExercise 16.1 Use proof by induction to show that \\[\n\\frac{1}{(1 - x)^k} = \\sum_{n = 0}^\\infty \\binom{n + k - 1}{k - 1} x^n.\n\\] Use the derivative to go from case \\(k\\) to case \\(k + 1\\). Take the geometric series as the base case (\\(k = 1\\)).\nHint: the derivative is going to reduce the exponent from \\(x^n\\) to \\(x^{n - 1}\\) so to get a step ahead of that, we can add \\(1\\) everywhere we see \\(n\\): \\[\n\\frac{1}{(1 - x)^k} = \\sum_{n + 1 = 0}^\\infty \\binom{n + k}{k - 1} x^{n + 1}.\n\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Stars and Bars Revisited</span>"
    ]
  },
  {
    "objectID": "generating-functions/stars-and-bars-revisited.html#variations-of-stars-and-bars",
    "href": "generating-functions/stars-and-bars-revisited.html#variations-of-stars-and-bars",
    "title": "16  Stars and Bars Revisited",
    "section": "16.2 Variations of Stars and Bars",
    "text": "16.2 Variations of Stars and Bars\nHow do do the stars and bars problem where every person gets at least \\(1\\) object? Let’s look back at our work:\n\nBroke up the problem into a concatenation \\(L_1 L_2 \\cdots L_k\\)\n\\(L_i = \\{\\varepsilon, i, ii, iii, \\dots\\}\\)\nThe generating function of \\(L_i\\) is \\(\\frac{1}{1 - x}\\)\nUse the multiplication principle to conclude that the generating function of \\(L_1 L_2 \\cdots L_k\\) is \\(\\frac{1}{(1 - x)^k}\\)\n\nThe second step is where we need to start making changes; if each person gets at least \\(1\\) object, then \\(L_i\\) should instead be \\(\\{i, ii, iii, \\dots\\}\\) with generating function\n\\[\nx^{f(i)} + x^{f(ii)} + x^{f(iii)} + \\dots = x + x^2 + x^3 + \\dots = \\frac{x}{1 - x}.\n\\]\n\n\n\n\n\n\nTipGeneral Geometric Series\n\n\n\n\n\nIn general, a geometric series will have some initial term \\(a\\) and then each succesive term is multiplied by a common ratio \\(r\\). We can factor out the initial term \\(a\\) to evaluate: \\[\na + ar + ar^2 + ar^3 + \\cdots = a(1 + r + r^2 + r^3 + \\cdots) = \\frac{a}{1 - r}.\n\\] Mnemonic: “initial term over \\(1\\) minus the common ratio.” E.g. \\(3x + 6x^3 + 12x^5 + 24x^7 + \\cdots\\) has an inital term of \\(3x\\) and a common ratio of \\(2x^2\\). So this evaluates to \\(\\frac{3x}{1 - 2x^2}\\).\n\n\n\nSubstituting this new generating function into our previous steps, we find that the stars-and-bars generating function with everyone getting at least \\(1\\) object is \\[\n\\left( \\frac{x}{1 - x} \\right)^k = \\frac{x^k}{(1 - x)^k} = x^k \\sum_{n = 0}^\\infty \\binom{n + k - 1}{k - 1} x^n = \\sum_{n = 0}^\\infty \\binom{n + k - 1}{k - 1} x^{n + k}.\n\\]\nIn order to get the number of solutions with \\(m\\) objects, we need the coefficient of \\(x^m\\), so we need \\(n + k = m\\). Changing \\(n + k\\) to \\(m\\), we get\n\\[\n\\frac{x^k}{(1 - x)^k} = \\sum_{m = k}^\\infty \\binom{m - 1}{k - 1} x^{m}.\n\\]\nThis matches our result of \\(\\binom{m - 1}{k - 1}\\) ways to distribute \\(m\\) objects to \\(k\\) people, with each person receiving at least \\(1\\).\n\n16.2.1 Other restrictions\nLet’s take the problem \\[\nx_1 + x_2 + \\cdots + x_k = n,\n\\] where \\(x_i \\ge 1\\). Now consider a restriction like \\(5 \\le x_1 \\le 13\\). This changes the language \\(L_1\\) to \\(\\{11111, 111111, \\cdots, 1111111111111\\}\\) and the generating function of \\(L_1\\) to \\[\nx^5 + x^6 + \\cdots + x^{13} = \\frac{x^5 - x^{14}}{1 - x}.\n\\]\n\n\n\n\n\n\nTipFinite Geometric Sums\n\n\n\n\n\nSuppose we have a finite geometric sum with initial term \\(a\\), common ratio \\(r\\) and proceeding for some number of steps. Then using the same method as Section 14.3, we can compute the sum \\[\\begin{align*}\nS &= a + ar + ar^2 + \\cdots + ar^m \\\\\nrS &= \\phantom{a + {}} ar + ar^2 + \\cdots + ar^m + ar^{m + 1} \\\\\nS - rS &= a \\phantom{{}+ar + ar^2 + \\cdots + ar^m} - ar^{m + 1}.\n\\end{align*}\\] This yields the formula \\(S = \\frac{a - ar^{m + 1}}{1 - r}\\). Mnemonic: take the initial term and subtract from it the term which would come after the last term (first minus next) over \\(1 - r\\).\n\n\n\nCombining this with the generating functions \\(\\frac{x}{1 - x}\\) for \\(L_2, L_3, \\dots, L_k\\), our restricted problem has an overal generating function of \\[\n\\frac{x^5 - x^{14}}{1 - x} \\cdot \\left( \\frac{x}{1 - x} \\right)^{k - 1} = \\frac{x^{k - 1}(x^{5} - x^{14})}{(1 - x)^k}.\n\\]\nWe will cover how to read the number of solutions from such a generating function in the next section. For now, let’s address one last modification.\n\n\n\n\n\n\nNoteGeneral Method\n\n\n\nLet \\(L_1\\) represent the possible number of objects person \\(1\\) can receive. E.g.\n\nif person \\(1\\) receives \\(0\\) or more, then \\(L_1 = \\{\\varepsilon, 1, 11, 111, \\dots\\}\\)—with OGF \\(x^0 + x^1 + x^2 + \\cdots = \\frac{1}{1 - x}\\)\nif person \\(1\\) receives \\(1\\) or more, then \\(L_1 = \\{1, 11, 111, \\dots\\}\\)—with OGF \\(x^1 + x^2 + x^3 + \\cdots = \\frac{x}{1 - x}\\)\nif person \\(1\\) receives \\(0, 1, 2\\), then \\(L_1 = \\{\\varepsilon, 1, 11\\}\\)—with OGF \\(x^0 + x^1 + x^2\\)\nif person \\(1\\) receives an even number, then \\(L_1 = \\{\\varepsilon, 11, 1111, \\dots\\}\\)—with OGF \\(x^0 + x^2 + x^4 + \\cdots = \\frac{1}{1 - x^2}\\).\n\nDo this for each person and then multiply the OGFs together for the full problem.",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Stars and Bars Revisited</span>"
    ]
  },
  {
    "objectID": "generating-functions/stars-and-bars-revisited.html#slack-variables",
    "href": "generating-functions/stars-and-bars-revisited.html#slack-variables",
    "title": "16  Stars and Bars Revisited",
    "section": "16.3 Slack variables",
    "text": "16.3 Slack variables\nConsider the problem \\[\nx_1 + x_2 + \\dots + x_k \\le n\n\\] with \\(x_i \\ge 0\\).\nThe method for solving this is to add a slack variable \\(y\\) with \\(y \\ge 0\\). This adds to our proceedure a \\(k + 1\\)-st language \\(L_y\\). This gives us the generating function\n\\[\n\\frac{1}{(1 - x)^{k + 1}} = \\sum_{n = 0}^\\infty \\binom{n + k}{k} x^n\n\\]\nIndeed, the coefficient \\(\\binom{n + k}{k}\\) matches our previous solution to this problem.\nIf on the other hand we had \\(x_i \\ge 1\\) then the generating functions for the \\(L_i\\) languages is \\(\\frac{x}{1 - x}\\) and we multiply this still by \\(\\frac{1}{1 - x}\\) for \\(L_y\\). Here there is an asymmetry between \\(L_y\\), which contains the empty string, and the languages \\(L_i\\) which don’t. So for this problem, we have\n\\[\n\\frac{x^k}{(1 - x)^{k + 1}} = x^k \\sum_{n = 0}^\\infty \\binom{n + k}{k} x^n = \\sum_{n = 0}^\\infty \\binom{n + k}{k} x^{n + k} =  \\sum_{n = k}^\\infty \\binom{n}{k} x^n.\n\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Stars and Bars Revisited</span>"
    ]
  },
  {
    "objectID": "generating-functions/stars-and-bars-revisited.html#sec-sb-ogf-summary",
    "href": "generating-functions/stars-and-bars-revisited.html#sec-sb-ogf-summary",
    "title": "16  Stars and Bars Revisited",
    "section": "16.4 Summary",
    "text": "16.4 Summary\n\nFor \\(x_1 + \\dots + x_k = n\\) and \\(x_i \\ge 0\\), we have the OGF \\[\n\\frac{1}{(1 - x)^k} = \\sum_{n = 0}^\\infty \\binom{n + k - 1}{k - 1} x^n.\n\\]\nFor \\(x_1 + \\dots + x_k = n\\) and \\(x_i \\ge 1\\), we have the OGF \\[\n\\frac{x^k}{(1 - x)^k} = \\sum_{n = k}^\\infty \\binom{n - 1}{k - 1} x^n.\n\\]\nFor \\(x_1 + \\dots + x_k \\le n\\) and \\(x_i \\ge 0\\), we have the OGF \\[\n\\frac{1}{(1 - x)^{k + 1}} = \\sum_{n = 0}^\\infty \\binom{n + k}{k} x^n.\n\\]\nFor \\(x_1 + \\dots + x_k = n\\) and \\(x_i \\ge 1\\), we have the OGF \\[\n\\frac{x^k}{(1 - x)^{k + 1}} = \\sum_{n = k}^\\infty \\binom{n}{k} x^n.\n\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Stars and Bars Revisited</span>"
    ]
  },
  {
    "objectID": "generating-functions/coefficient-extraction.html",
    "href": "generating-functions/coefficient-extraction.html",
    "title": "17  Coefficient Extraction",
    "section": "",
    "text": "17.1 Shifts\nIn this section, we develop some techniques for extracting coefficients from generating functions. Remember that coefficient of \\(x^n\\) represents the number of solutions of weight \\(n\\). So knowing that the generating function is, for example,\n\\[\nA(x) = \\frac{x^{k - 1}(x^5 - x^{14})}{(1 - x)^k} = \\sum a_n x^n,\n\\]\nour goal is to find \\(a_n\\). A common notation for this is \\(a_n = [x^n] A(x)\\).\nMultiplying \\(A(x)\\) by \\(x^k\\) shifts the sequence left or right (depending on whether \\(k\\) is positive or negative): \\[\nx^k \\sum a_n x^n = \\sum a_n x^{n + k} = \\sum a_{n - k} x^n.\n\\] The second equals sign is obtained either by substituting \\(n \\gets n + k\\) or by noticing that the coefficient is always \\(k\\) less than the exponent.\nPutting this together, we have the following result.",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Coefficient Extraction</span>"
    ]
  },
  {
    "objectID": "generating-functions/coefficient-extraction.html#shifts",
    "href": "generating-functions/coefficient-extraction.html#shifts",
    "title": "17  Coefficient Extraction",
    "section": "",
    "text": "TipSubstituting inside a sum\n\n\n\n\n\nConsider a summation like \\[\n\\sum_{k = 2}^\\infty k(k-1)x^{k - 2}.\n\\] If we want to write this as a sum where \\(x^k\\) is the exponent in our summand, then we can either\n\nadd \\(2\\) everywhere we see \\(k\\): \\[\n\\sum_{k + 2 = 2}^\\infty (k + 2)(k + 1)x^{k} = \\sum_{k = 0}^\\infty (k + 2)(k + 1)x^{k},\n\\]\nmake a substitution of \\(n = k - 2\\) and \\(k = n + 2\\) to get \\[\n\\sum_{n + 2 = 2}^\\infty (n + 2)(n + 1)x^{n}.\n\\]\n\nBoth methods are equivalent.\n\n\n\n\n\nTheorem 17.1 (Coefficient Shift) If \\(A(x) = \\sum a_nx^n\\) then \\[\n[x^n]x^kA(x) = [x^{n - k}] A(x) = a_{n - k}.\n\\] “The coefficient of \\(x^n\\) in \\(x^k A(x)\\) is \\(a_{n - k}\\).”",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Coefficient Extraction</span>"
    ]
  },
  {
    "objectID": "generating-functions/coefficient-extraction.html#sums-and-differences",
    "href": "generating-functions/coefficient-extraction.html#sums-and-differences",
    "title": "17  Coefficient Extraction",
    "section": "17.2 Sums and differences",
    "text": "17.2 Sums and differences\nSuppose \\(A(x) = \\sum a_n x^n, B(x) = \\sum b_n x^n\\) are two power series. Then for any constants \\(\\lambda, \\mu\\), we have \\[\n\\lambda A(x) + \\mu B(x) = \\lambda \\sum a_n x^n + \\mu \\sum b_n x^n = \\sum (\\lambda a_n + \\mu b_n) x^n.\n\\] In terms of our \\([x^n]\\) operator, we record the following result.\n\nTheorem 17.2 (Linear Combinations) \\[\n[x^n](\\lambda A(x) + \\mu B(x)) = \\lambda [x^n] A(x) + \\mu [x^n] B(x).\n\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Coefficient Extraction</span>"
    ]
  },
  {
    "objectID": "generating-functions/coefficient-extraction.html#derivatives",
    "href": "generating-functions/coefficient-extraction.html#derivatives",
    "title": "17  Coefficient Extraction",
    "section": "17.3 Derivatives",
    "text": "17.3 Derivatives\nAs we saw earlier, \\[\nA'(x) = \\sum na_nx^{n - 1} = \\sum (n + 1)a_{n + 1}x^n.\n\\]\n\nTheorem 17.3 (Derivatives and Antiderivatives) \\[\n[x^n] A'(x) = (n + 1) [x^{n + 1}] A(x).\n\\] Or for antiderivatives, \\[\n[x^n] A(x) = \\frac{1}{n} [x^{n - 1}] A'(x).\n\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Coefficient Extraction</span>"
    ]
  },
  {
    "objectID": "generating-functions/coefficient-extraction.html#newtons-binomial-theorem",
    "href": "generating-functions/coefficient-extraction.html#newtons-binomial-theorem",
    "title": "17  Coefficient Extraction",
    "section": "17.4 Newton’s Binomial Theorem",
    "text": "17.4 Newton’s Binomial Theorem\nWe’ve seen the Binomial Theorem, \\[\n(1 + x)^n = \\sum_{k = 0}^n \\binom{n}{k}x^k.\n\\] And, in the previous section, we worked out power series for \\((1 - x)^{-n}\\). These kinds of functions are quite common in combinatorics, and not just for integer exponents either.\n\nDefinition 17.1 The general binomial coefficient is \\[\n\\binom{r}{k} = \\frac{r(r - 1)(r - 2) \\cdots (r - k + 1)}{k!}\n\\] and we define this for any real (or complex) number \\(r\\).\n\nWhat Newton observed, is that when you take the derivative of \\(f(x) = (1 + x)^r\\) a few times, you get \\[\nr(1+x)^{r - 1} \\text{ then } r(r - 1) (1 + x)^{r - 2} \\text{ then } r(r - 1)(r - 2)(1 + x)^{r - 3}, \\dots\n\\]\n\nTheorem 17.4 (Newton’s Binomial Theorem) The Taylor series of \\((1 + x)^r\\) is \\[\n\\sum_{k = 0}^\\infty \\binom{r}{k}x^k.\n\\]\n\n\nProof. We’ve seen above that for \\(f(x) = (1 + x)^r\\), we have \\[\nf^{(k)}(x) = r(r-1)(r-2)\\cdots(r - k + 1)(1 + x)^{r - k}.\n\\] Plugging this into the formula for a Taylor series, \\[\n(1 + x)^r = \\sum_{k = 0}^\\infty \\frac{f^{(k)}(0)}{k!} x^k = \\sum_{k = 0}^\\infty \\frac{r(r - 1)(r - 2) \\cdots (r - k + 1)}{k!} = \\sum_{k = 0}^\\infty \\binom{r}{k}x^k.\n\\]\n\n\n\n\n\n\n\nNote\n\n\n\nThese series converge for at least \\(|x| &lt; 1\\) (and so techniques of calculus apply to analyzing these series). Convergence for \\(x = \\pm 1\\) depends on \\(r\\). And of course, if \\(r\\) is a whole number then the series is finite and converges everywhere.",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Coefficient Extraction</span>"
    ]
  },
  {
    "objectID": "generating-functions/coefficient-extraction.html#examples",
    "href": "generating-functions/coefficient-extraction.html#examples",
    "title": "17  Coefficient Extraction",
    "section": "17.5 Examples",
    "text": "17.5 Examples\nLet’s finally get to solving the problem of Section 16.2.1. Recall that we had the generating function \\[\nA(x) = \\frac{x^{k - 1}(x^5 - x^{14})}{(1 - x)^k} = \\frac{x^{k + 4} - x^{k + 13}}{(1 - x)^k}.\n\\] Now we’re going to combine this with the first formula from Section 16.4 to get \\[\\begin{align*}\n[x^n] \\frac{x^{k + 4} - x^{k + 13}}{(1 - x)^k} &= [x^n] x^{k + 4} \\frac{1}{(1 - x^k)} - [x^n] x^{k + 13} \\frac{1}{(1 - x)^k} \\\\\n&= [x^{n - k - 4}] \\frac{1}{(1 - x)^k} - [x^{n - k - 13}] \\frac{1}{(1 - x)^k} \\\\\n&= \\binom{(n - k - 4) + k - 1}{k - 1} - \\binom{(n - k - 13) + k - 1}{k - 1} \\\\\n&= \\binom{n - 5}{k - 1} - \\binom{n - 14}{k - 1}.\n\\end{align*}\\]\n\n\n\n\n\n\nTipCoefficient extraction with the formulas\n\n\n\n\n\nThe formula from Section 16.4 says \\[\n\\frac{1}{(1 - x)^k} = \\sum_{n = 0}^\\infty \\binom{n + k - 1}{k - 1}x^n.\n\\] That means that the coefficient of \\(x^n\\) is \\[\n[x^n] \\frac{1}{(1 - x)^k} = \\binom{n + k - 1}{k - 1}.\n\\] If we want to apply this to a more complex power of \\(x\\), we do so by substituting where we see \\(n\\), for example, \\[\n[x^{n + 1}] \\frac{1}{(1 - x)^k} = \\binom{(n + 1) + k - 1}{k - 1} = \\binom{n + k}{k - 1}.\n\\]\n\n\n\n\n17.5.1 Negative Binomial Theorem\nComparing Theorem 17.4 and formula (a.) of Section 16.4 yields an interesting result:\n\\[\n\\frac{1}{(1 - x)^k} = \\sum_{n = 0}^\\infty \\binom{n + k - 1}{k - 1} x^n = \\sum_{n = 0}^\\infty \\binom{-k}{n} (-x)^n.\n\\tag{17.1}\\] Note that we are looking at \\((1 - x)^{-k}\\) not \\((1 + x)^{-k}\\) hence the \\((-x)\\) on the right.\nThe next theorem is most often stated with \\(n\\) and \\(k\\) swapped. We also use the identity \\(\\binom{a + b}{a} = \\binom{a + b}{b}\\).\n\nTheorem 17.5 (Negative Binomial Theorem) \\[\n\\binom{-k}{n} (-1)^n = \\binom{n + k - 1}{k - 1} = \\binom{n + k - 1}{n}.\n\\] Or, with \\(n\\) and \\(k\\) in the usual position: \\[\n\\binom{-n}{k} (-1)^k = \\binom{n + k - 1}{n - 1} = \\binom{n + k - 1}{k}.\n\\]\n\nLike many things in combinatorics, it’s interesting to give a second proof of this beyond the generating function proof in Equation 17.1.\n\nProof. \\[\\begin{align*}\n\\binom{-n}{k} (-1)^k &= \\frac{(-n)(-n - 1)(-n - 2)\\cdots(-n-k+1)}{k!} (-1)^k \\\\\n&= \\frac{(n)(n + 1)(n + 2)\\cdots(n+k-1)}{k!} \\\\\n&= \\frac{(n + k - 1)(n + k - 2) \\cdots (n + 1)(n)}{k!} \\\\\n&= \\binom{n + k - 1}{k}.\n\\end{align*}\\] In line 2, we distribute one \\(-1\\) to each of the \\(k\\) factors in the numerator.\n\n\n\n17.5.2 Central Binomial Theorem\nWe’ve seen the binomial theorem with a whole number exponent. We’ve seen it with a negative integer exponent. The next place to go is fractions. Let’s start with \\(n = \\frac12\\). For reference, here are the first couple values of this:\n\nfor k in range(4):\n    print(binomial(1/2, k))\n\n1\n1/2\n-1/8\n1/16\n\n\nIt would seem that these are \\(\\pm 1\\) over some power of \\(2\\) but if we continue our computation, we find that the next value is \\(-5/128\\).\nIn order to get to the bottom of this, we need to work this out from the definition:\n\\[\\begin{align*}\n\\binom{1/2}{k} &= \\frac{\\frac12(\\frac12 - 1)(\\frac12 - 2)\\cdots(\\frac12 - k + 1)}{k!} \\\\\n&= \\frac{\\frac12 (-\\frac12)(-\\frac32)(-\\frac52) \\cdots (-\\frac{2k - 3}{2})}{k!} \\\\\n&= \\frac{(-\\frac12)^{k-1}(1)(3)(5)\\cdots(2k-3)}{2k!} \\\\\n&= (-1)^{k-1}\\frac{(1)(3)(5)\\cdots(2k-3)}{2^kk!}. \\\\\n\\end{align*}\\]\nThis is a pretty good formula. We can also write it in terms of the double factorial which is the product of all the odd numbers up to \\(2k - 3\\). (It’s called double because the factors decrease by \\(2\\) each time instead of \\(1\\).)\nBut like in the Wikipedia article, we can write double factorials in terms of more usual factorials. We do this by adding in the missing even numbers to the numerator and balancing that out in the denominator:\n\\[\\begin{align*}\n\\binom{1/2}{k} &= (-1)^{k-1}\\frac{(1)(3)\\cdots(2k-3) \\cdot (2)(4) \\cdots (2k - 2)}{2^kk! \\cdot (2)(4) \\cdots (2k - 2)} \\\\\n&= (-1)^{k-1}\\frac{(1)(2)(3)\\cdots(2k-3)(2k - 2)}{2^kk! \\cdot 2^{k-1} (1)(2) \\cdots (k - 1)} \\\\\n&= (-1)^{k-1}\\frac{(2k - 2)!}{2^{2k-1}k!(k - 1)!} \\\\\n&= (-1)^{k-1} \\frac{1}{2^{2k - 1}k} \\binom{2k-2}{k - 1}\n\\end{align*}\\]\nLet’s do this once more with \\(n = -1/2\\) but going through the steps a bit quicker:\n\\[\\begin{align*}\n\\binom{-1/2}{k} &= \\frac{(-\\frac12)(-\\frac32)(-\\frac52) \\cdots (-\\frac{2k - 1}{2})}{k!} \\\\\n&= (-1)^k \\frac{1 \\cdot 3 \\cdot 5 \\cdots (2k - 1)}{2^k k!} \\\\\n&= (-1)^k \\frac{(2k)!}{2^k k! \\cdot (2)(4) \\cdots (2k)} \\\\\n&= (-1)^k \\frac{(2k)!}{2^k k! \\cdot 2^k k!} \\\\\n&= (-1)^k \\frac{1}{4^k} \\binom{2k}{k}.\n\\end{align*}\\]\nLet us record these results as a theorem.\n\nTheorem 17.6 (Half Binomials) \\[\n\\binom{1/2}{k} = (-1)^{k-1} \\frac{1}{2^{2k - 1}k} \\binom{2k-2}{k - 1} \\text{ and } \\binom{-1/2}{k} = \\frac{(-1)^k}{4^k} \\binom{2k}{k}.\n\\] The first formula is only valid for \\(k \\ge 1\\). If \\(k = 0\\) then we get \\(\\binom{1/2}{0} = 1\\) (product of zero terms in the numerator equals \\(1\\) and the denominator is \\(0! = 1\\)).\n\n\nExample 17.1 Take the second formula, and use it with Theorem 17.4. We will put \\((-4x)^k\\) instead of \\(x^k\\) to cancel the \\((-1/4)^k\\). That is, \\[\\begin{align*}\n\\frac{1}{\\sqrt{1 - 4x}} = (1 - 4x)^{-1/2} &= \\sum_{k = 0}^\\infty \\binom{-1/2}{k} (-4x)^k \\\\\n&= \\sum_{k = 0}^\\infty \\frac{(-1)^k}{4^k} \\binom{2k}{k} (-4x)^k \\\\\n&= \\sum_{k = 0}^\\infty \\binom{2k}{k} x^k \\\\\n\\end{align*}\\]\n\nThis is a neat little result in and of itself but there is deeper implications here. Consider the number of binary strings of length \\(2k\\) with an equal number of \\(0\\)s and \\(1\\)s. That means there are \\(k\\) of each, and that gives us the formula \\(\\binom{2k}{k}\\). These are called the central binomial coefficients because they appear right down the center of Pascal’s triangle.\nFor those of you who have taken computer science or mathematical linguistics, there is a concept known as a “regular language”—languages which can be parsed by a regular expresion1. For these regular languages, we will see later on, that they always yeild a rational generating function. Here we have a non-rational generating function and indeed this language of strings with equal numbers of \\(0\\)s and \\(1\\)s is not a regular language.\nGoing beyond regular languages, the Chomsky–Schützenberger Theorem says that if you have an unambiguous context-free grammar, then the generating function for that language is algebraic. That is what we are looking at with \\(\\frac{1}{\\sqrt{1 - 4x}}\\). This is an algebraic function because it is a square root of a rational function. Indeed, the language of strings with equal numbers of \\(0\\)s and \\(1\\)s is a context-free language.\n\n\n17.5.3 Catalan Numbers\nIf you remember the formula for the Catalan numbers even vaguely, you’ll recognize the \\(\\binom{2k}{k}\\). If you squint real hard, the first formula of Theorem 17.6 looks vaguely similar once you deal with the \\((-1)^k\\) and the \\(4^k\\) as we did in Example 17.1. Let’s dig into that.\nFirst, recall the decomposition we had for Dyck paths.\n\n\n\nDyck path decomposition based on the first place the path hits the line \\(y = x\\)\n\n\nIn terms of “the language of Dyck paths,” what this says is that a Dyck path of length \\(n\\) is equal to\n\na shift one step up from the diagonal\na Dyck path of length \\(k - 1\\)\na Dyck path of length \\(n - k\\)\n\nHere’s the beauty of generating functions: as long as we keep track of the shifts, we don’t need to keep track of the lengths of the subwords or subpaths. So we can describe the language of Dyck paths in simpler terms: it is a shift, together with two smaller Dyck paths. Therefore, if we represent our shift by the monomial \\(x\\), and our Catalan generating function by \\(C(x)\\), what we have here is \\(xC(x)^2\\).\nWe almost have it, we just need to be careful of the edge case. If \\(n = 0\\), the path from \\((0,0)\\) to \\((0,0)\\) is a valid Dyck path which involves no shift. So a Dyck path is either\n\nthis length \\(0\\) Dyck path, which has OGF \\(x^0 = 1\\)\na shift, together with two Dyck paths, with OGF \\(xC(x)^2\\).\n\nTherefore, \\(C(x)\\) satisfies the equation \\[\nC(x) = 1 + xC(x)^2.\n\\]\nIf you solve this quadratic equation using the quadratic formula, we find that \\[\nC(x) = \\frac{1 \\pm \\sqrt{1 - 4x}}{2x}.\n\\tag{17.2}\\]\nIn order to get numbers out of this, we use Theorem 17.4 to expand the square root (separating the \\(k = 0\\) term so we can apply the formula from Theorem 17.6): \\[\\begin{align*}\n\\sqrt{1 - 4x} &= 1 + \\sum_{k = 1}^\\infty \\binom{1/2}{k}(-4x)^k \\\\\n&= 1 + \\sum_{k = 1}^\\infty (-1)^{k-1} \\frac{1}{2^{2k - 1}k} \\binom{2k-2}{k - 1} (-4x)^k \\\\\n&= 1 + \\sum_{k = 1}^\\infty \\frac{-2}{k} \\binom{2k-2}{k - 1} x^k.\n\\end{align*}\\]\nThe presence of the \\(-\\) sign indicates that we want to use the negative square root in Equation 17.2. Doing this, we obtain\n\\[\\begin{align*}\n- \\sqrt{1 - 4x} &= - 1 + \\sum_{k = 1}^\\infty \\frac{2}{k} \\binom{2k-2}{k - 1} x^k \\\\\n1 - \\sqrt{1 - 4x} &= \\sum_{k = 1}^\\infty \\frac{2}{k} \\binom{2k-2}{k - 1} x^k \\\\\n\\frac{1 - \\sqrt{1 - 4x}}{2x} &= \\sum_{k = 1}^\\infty \\frac{1}{k} \\binom{2k-2}{k - 1} x^{k - 1} \\\\\n&= \\sum_{k = 0}^\\infty \\frac{1}{k + 1} \\binom{2k}{k} x^k\n\\end{align*}\\] (adding \\(1\\) to each \\(k\\) to get from \\(k - 1\\) to \\(k\\)).\nWe’ve now found another way to get our Catalan number formula.\n\nTheorem 17.7 (Catalan OGF) The generating function for the Catalan numbers is \\[\nC(x) = \\frac{1 - \\sqrt{1 - 4x}}{2x} = \\sum_{k = 0}^\\infty \\frac{1}{k + 1} \\binom{2k}{k} x^k.\n\\]",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Coefficient Extraction</span>"
    ]
  },
  {
    "objectID": "generating-functions/coefficient-extraction.html#footnotes",
    "href": "generating-functions/coefficient-extraction.html#footnotes",
    "title": "17  Coefficient Extraction",
    "section": "",
    "text": "We’ll define many of these terms in a later section for those of you who haven’t seen them before.↩︎",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Coefficient Extraction</span>"
    ]
  },
  {
    "objectID": "generating-functions/generating-function-exercises.html",
    "href": "generating-functions/generating-function-exercises.html",
    "title": "18  Exercises",
    "section": "",
    "text": "Given that \\(\\displaystyle \\frac{1}{1 - ax} = \\sum_{n = 0}^\\infty a^n x^n\\), convert the following into summation notation (in terms of \\(x^n\\) rather than \\(x^{n + k}\\))\n\n\\(\\dfrac{1}{1 - x} + \\dfrac{1}{1 + x}\\)\n\\(\\dfrac{x^3}{1 + 2x}\\)\n\\(\\displaystyle \\int_{0}^x \\frac{1}{1 - t} \\; dt = \\log\\left( \\frac{1}{1 - x} \\right)\\) (hint: take the antiderivative/integral term by term)\n\\(\\dfrac{3}{2 - x}\\) (hint: convert to \\(\\dfrac{a}{1 - bx}\\))\n\\(\\dfrac{1 + x}{1 - x^3}\\) (hint: split the fraction into two fractions)\n\n\n\n\n\n\n\n\nTipHints\n\n\n\n\n\n\nStart with \\[\n\\frac{1}{1 - y} = \\sum_{n = 0}^\\infty y^n\n\\] where maybe \\(y = x^3\\) and we get \\(x^{3n}\\) or \\(y = -x\\) and we get \\((-x)^n\\).\nIf we multiply by \\(x^3\\) and get \\(\\sum a^n x^{n + 3}\\) then subtract \\(3\\) from \\(n\\) everywhere to get \\(\\sum a^{n - 3} x^n\\). For the bottom of the summation, we would change from \\(n = 0\\) to \\(n - 3 = 0\\) or \\(n = 3\\).\nIf we integrate \\(\\sum x^n\\) term by term, we get \\(\\sum x^{n + 1}{n + 1}\\).\nConvert to \\(\\dfrac{3/2}{1 - x/2}\\).\nYou can write your answer as \\(\\sum a_n x^n\\) where \\(a_n = \\dots\\) (formula will depend on if \\(n = 3k, 3k + 1, 3k + 2\\)).\n\n\n\n\n\nConvert each sequence to a closed form generating function. Use the most obvious choice of form for the general term of the sequence. Sequences start at \\(n = 0\\).\n\n\\(2, 2, 2, 2, 2, 2, \\dots\\)\n\\(0, 1, 0, 1, 0, 1, \\dots\\)\n\\(1, 0, 1, 0, 1, 0, \\dots\\)\n\\(0, 1, 2, 3, 4, 5, \\dots\\) (hint: factor out an \\(x\\) from \\(\\sum nx^n\\) so that the terms are \\(\\frac{d}{dx} x^n\\), then move the derivative operator outside the summation [but after the \\(x\\) that was factored out])\n\\(1, 3, 5, 7, 9, 11, \\dots\\) (hint: use part d)\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\n\nWrite it first as \\(\\sum 2x^n\\) and factor out the \\(2\\).\nWrite it first as \\(x + x^3 + x^5 + \\dots\\)\nWrite it first as \\(1 + x^2 + x^4 + \\dots\\)\n\\(\\displaystyle \\frac{d}{dx} \\frac{1}{1 - x} = \\frac{1}{(1 - x)^2} = \\sum nx^{n - 1}\\)\n\n\n\n\n\nUsing the formulas from section Section 16.4, find\n\n\\(\\displaystyle \\sum_{n = 0}^\\infty \\binom{n + 2}{2} x^n\\)\n\\(\\displaystyle \\sum_{n = 5}^\\infty \\binom{n - 1}{4} x^n\\)\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\n\nCan be plugged into the formula directly\nLook for the formula with \\(n - 1\\) and then figure out how to choose the right \\(k\\).\n\n\n\n\n\nFind the indicated coefficients.\n\n\\([x^{10}] \\dfrac{1}{1 + 2x}\\)\n\\([x^{20}] \\dfrac{1}{(1 - x)^7}\\)\n\\([x^{20}] \\dfrac{x^3}{(1 - x)^{10}}\\)\n\\([x^{85}] \\dfrac{2x^5}{1 - 3x^5}\\) (hint: if the sum is \\(\\sum (*) x^{5n + 5}\\) then the coefficient of \\(x^{85}\\) occurs where \\(5n + 5 = 85\\))\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\n\nUse the formula \\(\\sum (-2)^n x^n\\) and take the coefficient of \\(x^{10}\\)\nUse the formula from Section 16.4.\nFirst use the shift formula from Theorem 17.1 to write it as \\([x^{17}] \\dfrac{1}{(1 - x)^{10}}\\).\nThe sum is \\(\\sum 2 \\cdot 3^n x^{5n + 5}\\)\n\n\n\n\n\nWrite down a generating function for the number of ways to make change for \\(n\\) dollars using \\(1, 5\\) and \\(10\\) dollar bills. (Hint: if we are receiving multiples of \\(\\$5\\) bills, then the generating function should be \\(x^0 + x^5 + x^{10} + \\cdots\\) where the weight function of a bill is its dollar value.)\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\nIf the options for $5 bills are \\(0, 1, 2, \\dots\\) then we have \\(1 + x^5 + x^{10} + x^{15} + \\dots\\) where the coefficient gives the number of choices (only 1 way to have \\(k\\) bills of the same type) and the exponent gives the weight or how much it contributes. You should get geometric series for each bill value.\n\n\n\n\nRepeat the previous problem but now suppose we are only allowed to give out a maximum of one \\(\\$5\\) bill.\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\nSimilar to problem 5. but now there are only \\(0\\) or \\(1\\) choices for the $5 bill. So \\(1 + x^5\\) is the generating function for that denomination.\n\n\n\n\nAdditional practice\n\nFunction to SeriesSequence to Function\n\n\n Fill in the blank:\n\n\\[ \\frac{2}{1 - 3x} \\]\n\nis equal to \\(\\displaystyle \\sum_{n = 0}^\\infty (\\cdots) x^n\\).\n\n\n\n\n  \n    \n      \n        \n    \n\n    \n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n What is the leading term and common ratio for the generating function whose coefficients are:\n\n\\[ 2, -2, 2, -2, 2, -2, 2, -2, 2, -2, \\dots ? \\]\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \n\n    \n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n    \n\n    \n\n\n    \n        \n      \n      \n    \n  \n\n\n\n\n\n\n\n\nHint: the leading term and common ratio might depend on \\(x\\) after you turn the sequence into \\(a_0 + a_1x + a_2x^2 + a_3x^3 + \\cdots\\).\n\n\n\n\n\nSolutions\n\n\n\n\\(\\displaystyle \\sum_{n = 0}^\\infty ((-1)^n + 1) x^n\\)\n\\(\\displaystyle \\sum_{n = 3}^\\infty (-2)^{n  - 3}x^n\\)\n\\(\\displaystyle \\sum_{n = 1}^\\infty \\frac{x^n}{n}\\)\n\\(\\displaystyle \\sum_{n = 0}^\\infty \\frac{3}{2^{n + 1}} x^n\\)\n\\(\\displaystyle \\sum_{n = 0}^\\infty a_n x^n\\) where \\(a_n = 0\\) if \\(n = 3k + 2\\) and \\(a_n = 1\\) otherwise (so the sequence \\(1, 1, 0, 1, 1, 0, 1, 1, 0, \\dots\\)).\n\n\n\\(\\dfrac2{1 - x}\\)\n\\(\\dfrac{x}{1 - x^2}\\)\n\\(\\dfrac{1}{1 - x^2}\\)\n\\(\\dfrac{x}{(1 - x)^2}\\)\n\\(\\displaystyle \\sum (2n + 1) x^n = 2\\sum n x^n + \\sum x^n = \\frac{2}{(1 - x)^2} + \\frac{1}{1 - x}\\).\n\n\n\\(\\dfrac{1}{(1 - x)^3}\\)\n\\(\\dfrac{x^5}{(1 - x)^5}\\)\n\n\n\\((-2)^{10}\\)\n\\(\\dbinom{26}{6}\\)\n\\(\\dbinom{26}{9}\\)\n\\(2 \\cdot 3^{16}\\)\n\n\\(\\dfrac1{(1 - x)(1 - x^5)(1 - x^{10})}\\)\n\\(\\dfrac{1 + x^5}{(1 - x)(1 - x^{10})}\\)",
    "crumbs": [
      "Generating Functions",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "regular-languages/regular-languages.html",
    "href": "regular-languages/regular-languages.html",
    "title": "19  Regular Languages",
    "section": "",
    "text": "19.1 Kleene Star\nAt this point we’ve seen numerous examples where a language is composed of a sequence of blocks.\nLet \\(L\\) be a language that does not contain the empty string (for reasons of unique representation). The language which repeats \\(L\\) in a sequence is called the Kleene star of \\(L\\), denoted \\(L^*\\). An element of \\(L^*\\) is some finite sequence \\[\nu_1 u_2 \\cdots u_k, \\text{ where } u_i \\in L.\n\\] Another name for such a sequence of length \\(k\\) is \\(L^k\\) (concatenating \\(k\\) strings from \\(L\\)). Thus, \\[\nL^* = L^0 \\cup L^1 \\cup L^2 \\cup L^3 \\cup \\cdots.\n\\] It’s also common notation to write these unions with a \\(+\\) sign to mean “or” (with a heavy implication that we want this to be disjoint). Also note that \\(L^0 = \\{\\varepsilon\\}\\) because concatenating \\(0\\) strings yields an empty string. So we have \\[\nL^* = \\varepsilon + L + L^2 + L^3 + \\cdots.\n\\]",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regular Languages</span>"
    ]
  },
  {
    "objectID": "regular-languages/regular-languages.html#kleene-star",
    "href": "regular-languages/regular-languages.html#kleene-star",
    "title": "19  Regular Languages",
    "section": "",
    "text": "19.1.1 Kleene Plus\nA related construction considers only the sequences of positive length. This is called the Kleene plus operator and it is defined by \\[\nL^+ = L + L^2 + L^3 + \\cdots.\n\\]",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regular Languages</span>"
    ]
  },
  {
    "objectID": "regular-languages/regular-languages.html#relation-to-generating-functions",
    "href": "regular-languages/regular-languages.html#relation-to-generating-functions",
    "title": "19  Regular Languages",
    "section": "19.2 Relation to Generating Functions",
    "text": "19.2 Relation to Generating Functions\nTheorem 14.1 and Theorem 15.1 imply the following theorem.\n\nTheorem 19.1 (Kleene star and plus) Provided the sets \\(L^0, L^1, L^2, \\dots\\) are disjoint, \\[\\begin{align*}\n\\Phi_{L^*} &= \\Phi_{L^0} + \\Phi_{L^1} + \\Phi_{L^2} + \\Phi_{L^3} + \\cdots \\\\\n&= \\Phi_L^0 + \\Phi_L^1 + \\Phi_L^2 + \\Phi_L^3 + \\cdots \\\\\n&= \\frac{1}{1 - \\Phi_L}.\n\\end{align*}\\] Similarly, \\[\\begin{align*}\n\\Phi_{L^+} &= \\Phi_L^1 + \\Phi_L^2 + \\Phi_L^3 + \\cdots \\\\\n&= \\frac{\\Phi_L}{1 - \\Phi_L}.\n\\end{align*}\\]",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regular Languages</span>"
    ]
  },
  {
    "objectID": "regular-languages/regular-languages.html#sec-regular-language-examples",
    "href": "regular-languages/regular-languages.html#sec-regular-language-examples",
    "title": "19  Regular Languages",
    "section": "19.3 Examples",
    "text": "19.3 Examples\nConsider our sequences of \\(1\\)s and \\(2\\)s which gave us the Fibonacci sequence. Here, unlike many previous examples, we don’t want to weight sequences by length but rather by sum (we’re looking for sequences whose sum is \\(n\\) not whose length is \\(n\\)). So let \\(f\\) denote the sum of a sequence, e.g. \\(f(122) = 1 + 2 + 2 = 5\\).\nLet \\(L = \\{1, 2\\}\\). Then \\(L^*\\) represents all sequences of \\(1\\)s and \\(2\\)s. By theorem Theorem 19.1, we have \\[\n\\Phi_{L^*} = \\frac{1}{1 - \\Phi_L} = \\frac{1}{1 - (x^{f(1)} + x^{f(2)})} = \\frac{1}{1 - x - x^2}.\n\\tag{19.1}\\]\nWe know that the number of these sequences which sum to \\(n\\) is counted by the Fibonacci sequence, so like we stated Section 14.3.1, we have\n\ntaylor(1/(1 - x - x^2), x, 0, 10)\n\n\\(\\displaystyle 89 \\, x^{10} + 55 \\, x^{9} + 34 \\, x^{8} + 21 \\, x^{7} + 13 \\, x^{6} + 8 \\, x^{5} + 5 \\, x^{4} + 3 \\, x^{3} + 2 \\, x^{2} + x + 1\\)\n\n\n\n19.3.1 Avoiding ‘11’\nIf we want to avoid \\(11\\) we need to make sure that everyone \\(1\\) has at least one \\(0\\) next to it. We can do this with the language \\(0^+1\\) which guarantees a zero on the left. Taking sequences of these, we get \\((0^+1)^*\\).\nWe’re getting close to the description. We also need to allow a potential initial \\(1\\) in case because that’s the place in the string which might have \\(0\\)s only on the right. So \\((\\varepsilon + 1)(0^+1)^*\\). Lastly, we can have as many zeros as we want after the last \\(1\\) so \\(L = (\\varepsilon + 1)(0^+1)^*0^*\\).\nHere we’re weighting by length again, so\n\n\\(\\Phi_{\\varepsilon + 1} = x^0 + x^1\\)\n\\(\\Phi_{0^+1} = \\frac{x}{1 - x} \\cdot x = \\frac{x^2}{1 - x}\\)\n\\(\\Phi_{(0^+1)^*} = \\frac{1}{1 - \\frac{x^2}{1 - x}}\\)\n\\(\\Phi_{0^*} = \\frac{1}{1 - x}\\)\n\nPutting that all together, we have \\[\n\\Phi_L = (1 + x) \\cdot \\frac{1}{1 - \\frac{x^2}{1 - x}} \\cdot \\frac{1}{1 - x} = \\frac{1 + x}{1 - x - x^2}.\n\\]\nThis is similar to Equation 19.1 but the numerator shifts the sequence over a step:\n\ntaylor((1 + x)/(1 - x - x^2), x, 0, 10)\n\n\\(\\displaystyle 144 \\, x^{10} + 89 \\, x^{9} + 55 \\, x^{8} + 34 \\, x^{7} + 21 \\, x^{6} + 13 \\, x^{5} + 8 \\, x^{4} + 5 \\, x^{3} + 3 \\, x^{2} + 2 \\, x + 1\\)",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regular Languages</span>"
    ]
  },
  {
    "objectID": "regular-languages/regular-languages.html#even-number-of-1s",
    "href": "regular-languages/regular-languages.html#even-number-of-1s",
    "title": "19  Regular Languages",
    "section": "19.4 Even number of 1s",
    "text": "19.4 Even number of 1s\nHeuristically, half of all binary strings should have an even number of \\(1\\)s and half should have an odd number. We’ll prove this using generating functions.\nFor a start, the language of binary strings can be written as \\((0 + 1)^*\\) (sequences of \\(0\\)s or \\(1\\)s). If we want to guarantee that every \\(1\\) is partnered with a second \\(1\\) later on, then we can modify this to \\(L = (0 + 10^*1)^*\\). Now we compute \\[\n\\Phi_{10^*1} = x \\cdot \\frac{1}{1 - x} \\cdot x = \\frac{x^2}{1 - x}.\n\\] So therefore, \\[\\begin{align*}\n\\Phi_L &= \\frac{1}{1 - (x + \\frac{x^2}{1 - x})} \\\\\n&= \\frac{1 - x}{(1 - x) - x(1 - x) - x^2} \\\\\n&= \\frac{1 - x}{1 - 2x} \\\\\n&= \\frac{1}{1 - 2x} - \\frac{x}{1 - 2x} \\\\\n&= \\sum_{n = 0}^\\infty 2^n x^n - \\sum_{n = 0}^\\infty 2^{n} x^{n + 1} \\\\\n&= \\sum_{n = 0}^\\infty 2^n x^n - \\sum_{n = 1}^\\infty 2^{n - 1} x^{n}.\n\\end{align*}\\]\nAnd that means that the number of such strings is \\[\n\\begin{cases}\n2^n - 2^{n - 1} = 2^{n - 1} & \\text{if } n \\ge 1 \\\\\n1 & \\text{if } n = 0\n\\end{cases}.\n\\]",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regular Languages</span>"
    ]
  },
  {
    "objectID": "regular-languages/regular-languages.html#regular-languages",
    "href": "regular-languages/regular-languages.html#regular-languages",
    "title": "19  Regular Languages",
    "section": "19.5 Regular Languages",
    "text": "19.5 Regular Languages\nWe describe regular languages inductively:\n\na finite language is regular\nif \\(L, L'\\) are regular then so is \\(L + L'\\)\nif \\(L, L'\\) are regular then so is \\(LL'\\)\nif \\(L, L'\\) are regular then so are \\(L^*\\) and \\(L^+\\)\n\nThat is, a regular language is everything you can create out of a finite description using unions, concatenations, Kleene stars and pluses, and letters from the alphabet.\nSuch a description using these operations is known as a regular expression. This concept is closely related to regular expressions in computer programming although computer programming includes many more operations such as the ? operator where \\(L? = \\varepsilon + L\\).\n\n\n\n\n\n\nNote\n\n\n\nSome regular expression operators in computer programming allow one to create languages which are not regular. For instance, back-references allow one to ask whether a previous part of the string has been repeated. So computer programming regular expressions exceeds what formal language regular expressions can describe. See Wikipedia for more info.",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regular Languages</span>"
    ]
  },
  {
    "objectID": "regular-languages/finite-automata.html",
    "href": "regular-languages/finite-automata.html",
    "title": "20  Finite Automata",
    "section": "",
    "text": "20.1 Interpreting a FSA\nAs we saw in Section 19.3, it can be a bit tricky to come up with a regular expression for a language. Often it’s easier to draw what is called a finite state automaton (FSA) instead. For instance, for the no \\(11\\)s language, we make states representing the last character seen as we move through the string and if the last character was a \\(1\\) and we see a second \\(1\\), we know the string should be thrown out.\nThe way to use a FSA is to input a string one digit at a time, let’s say from left to right. So if we take the string \\(010011\\) and input it into the automaton in Figure 20.1, we start in state \\(0\\). The arrow\nstateDiagram\n    direction LR\n    [*] --&gt; 0\n\n\n\n\nFigure 20.2: Start arrow\nindicates which state to start in.\nThen we read the first character in our string, which is \\(0\\) and this tells us to follow the edge labeled \\(0\\) from our current state, which puts us back in state \\(0\\).\nNext we read a \\(1\\) and this tells us to follow the edge labeled \\(1\\) and puts us in state \\(1\\). Then another \\(0\\) puts us back in state \\(0\\). Then state \\(0\\) again. Then state \\(1\\).\nWith the last \\(1\\), we try to follow an edge labeled \\(1\\) out of state \\(1\\), but there is no such edge. So at this point we fail and that means the string \\(010011\\) is rejected by the automaton.",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Finite Automata</span>"
    ]
  },
  {
    "objectID": "regular-languages/finite-automata.html#a-fsa-for-even-1s",
    "href": "regular-languages/finite-automata.html#a-fsa-for-even-1s",
    "title": "20  Finite Automata",
    "section": "20.2 A FSA for even ’1’s",
    "text": "20.2 A FSA for even ’1’s\nTo create this automaton, we need one state to represent an even number of \\(1\\)s and one state to represent an odd number of \\(1\\)s. To distinguish between success states and failure states, we will use a thick border on the success states.\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    classDef accept stroke-width:5px\n\n    [*] --&gt; 0\n    0 --&gt; 0 : 0\n    0 --&gt; 1 : 1\n    1 --&gt; 0 : 1\n    1 --&gt; 1 : 0\n\n    class 0 accept\n\n\n\n\nFigure 20.3: Automaton for an even number of \\(1\\)s\n\n\n\n\n\nThese success or failure states are used at the end of reading a string. If we finish in a success state, the string is good. If we finish in a failure state, the string is bad.",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Finite Automata</span>"
    ]
  },
  {
    "objectID": "regular-languages/finite-automata.html#state-elimination",
    "href": "regular-languages/finite-automata.html#state-elimination",
    "title": "20  Finite Automata",
    "section": "20.3 State Elimination",
    "text": "20.3 State Elimination\nLet’s have a look at how to turn a FSA into a regular expression. To do this, we will modify our automata step by step, marking each path by what regular expression goes through each state.\n\n20.3.1 One in, one out\nFor example, a state like\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; S : a\n    S --&gt; S : b\n    S --&gt; [*] : c\n\n\n\n\nFigure 20.4: Pre-state elimination\n\n\n\n\n\nCan be replaced by\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; [*] : ab*c\n\n\n\n\nFigure 20.5: Post-state elimination\n\n\n\n\n\nIn order to enter state \\(S\\) we need to see an \\(a\\), then we can use \\(b\\) as many times as we want, then we need to see a \\(c\\) to leave.\n\n\n20.3.2 Parallel edges\nGiven two parallel edges, we can combine them using \\(+\\) meaning “or”.\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; [*] : a\n    [*] --&gt; [*] : b\n\n\n\n\nFigure 20.6: Pre-state elimination for parallel edges\n\n\n\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; [*] : a + b\n\n\n\n\nFigure 20.7: Post-state elimination for parallel edges\n\n\n\n\n\nThis says to get from the first state to the second, we can take either \\(a\\) or \\(b\\).\n\n\n20.3.3 Multiple ins or outs\nSuppose we have multiple in-edges or out-edges on a state. We can replace the state with a path from each input to each output and record the expression for that path according to Section 20.3.1.\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    I1 --&gt; S : a\n    I2 --&gt; S : b\n    S --&gt; S : c\n    S --&gt; O1 : d\n    S --&gt; O2 : e\n\n\n\n\nFigure 20.8: Pre-state elimination for multiple edges\n\n\n\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    I1 --&gt; O1 : ac*d\n    I1 --&gt; O2 : ac*e\n    I2 --&gt; O1 : bc*d\n    I2 --&gt; O2 : bc*e\n\n\n\n\nFigure 20.9: Pre-state elimination for multiple edges\n\n\n\n\n\n\n\n20.3.4 Trinary Example\nConsider the language of trinary strings containing at least one \\(1\\) and one \\(2\\). Let’s setup states recording whether we’ve yet seen a \\(1\\), a \\(2\\) or both.\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; 0\n    0 --&gt; 0 : 0\n    0 --&gt; 01 : 1\n    0 --&gt; 02 : 2\n    01 --&gt; 01 : 0,1\n    02 --&gt; 02 : 0,2\n    01 --&gt; 012 : 2\n    02 --&gt; 012 : 1\n    012 --&gt; 012 : 0,1,2\n    012 --&gt; [*]\n\n\n\n\nFigure 20.10: FSA for trinary strings with at least one 1 and one 2\n\n\n\n\n\nIn order to eliminate every state, we make sure to have a starting and ending node that we can get an answer going from start to finish. There is only one accepting state here, “012”, which can go to the ending node whenever we finish.\nNext, we eliminate states “01” and “02” using Section 20.3.1.\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; 0\n    0 --&gt; 0 : 0\n    0 --&gt; 012 : 1(0+1)*2\n    0 --&gt; 012 : 2(0+1)*1\n    012 --&gt; 012 : 0,1,2\n    012 --&gt; [*]\n\n\n\n\nFigure 20.11: FSA for trinary strings with at least one 1 and one 2, begin state elimination\n\n\n\n\n\nThen we use Section 20.3.2 and finish off with Section 20.3.1 to eliminate the remaining states.\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; [*] : 0*[1(0+1)*2 + 2(0+2)*1](0 + 1 + 2)*0\n\n\n\n\nFigure 20.12: FSA for trinary strings with at least one 1 and one 2, finish state elimination\n\n\n\n\n\nThis gives us the regular expression \\[\n0^*[1(0+1)^*2 + 2(0+2)^*1](0+1+2)^*.\n\\]",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Finite Automata</span>"
    ]
  },
  {
    "objectID": "regular-languages/finite-automata.html#sec-fibonacci-FSA",
    "href": "regular-languages/finite-automata.html#sec-fibonacci-FSA",
    "title": "20  Finite Automata",
    "section": "20.4 Fibonacci Example",
    "text": "20.4 Fibonacci Example\nConsider the language of binary strings with no “11.” We can make an automata with three states: a good state where we can take anything, a state representing that we’ve last seen a “1” and one which represents that we’ve seen two “1”s in a row.\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; 0\n    0 --&gt; 0 : 0\n    0 --&gt; 1 : 1\n    1 --&gt; 0 : 0\n    1 --&gt; 11 : 1\n    11 --&gt; 11 : 0, 1\n    0 --&gt; [*] : ε\n    1 --&gt; [*] : ε\n\n\n\n\nFigure 20.13: FSA for binary strings with no 11\n\n\n\n\n\nAs before, we have a start and end state represented by just circles.\nSo first, we can eliminate the state for “11” since going there will never lead to a valid string.\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; 0\n    0 --&gt; 0 : 0\n    0 --&gt; 1 : 1\n    1 --&gt; 0 : 0\n    0 --&gt; [*] : ε\n    1 --&gt; [*] : ε\n\n\n\n\nFigure 20.14: FSA for binary strings with no 11, no sink state\n\n\n\n\n\nThe easiest state to eliminate here is state “1” because it has the fewest number of arrows and no loops. There is one path into state “1” and two out. So following Section 20.3.3, we replace these with the path \\(1\\varepsilon = 1\\) from state “0” to the end and with the path \\(10\\) from \\(0\\) back to itself.\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; 0\n    0 --&gt; 0 : 0\n    0 --&gt; 0 : 10\n    0 --&gt; [*] : 1\n    0 --&gt; [*] : ε\n\n\n\n\nFigure 20.15: FSA for binary strings with no 11, eliminate state 1\n\n\n\n\n\nWe now have some parallel loops and parallel edges, which we can add together to get a loop of \\(0 + 10\\) and an edge of \\(\\varepsilon + 1\\). So the regular expression we come to is \\[\n(0 + 10)^*(\\varepsilon + 1).\n\\]",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Finite Automata</span>"
    ]
  },
  {
    "objectID": "regular-languages/putting-it-together.html",
    "href": "regular-languages/putting-it-together.html",
    "title": "21  Putting Everything Together",
    "section": "",
    "text": "21.1 Trinary Example\nWe’ve done some examples where we take a description and create a finite state automaton. We’ve done state elimination to create regular expressions. So let’s look one last time at how to turn these regular expressions into formulae.\nIn Section 20.3.4, we had the regular expression \\[\n0^*[1(0 + 1)^*2 + 2(0 + 2)^*1](0 + 1 + 2)^*.\n\\]\nNow we could break this into sublanguages like \\(L_0 = \\{0\\}\\) and \\(\\Phi_{L_0} = x^{f(0)} = x^1\\) but we can streamline this a bit.\nLet’s illustrate: \\[\\begin{align*}\n&\\phantom{{}={}}\\; 0^*[1(0 + 1)^*2 + 2(0 + 2)^*1](0 + 1 + 2)^* \\\\\n&\\mapsto x^*[x(x + x)^*x + x(x + x)^*x](x + x + x)^* \\\\\n&= x^*[2x^2(2x)^*](3x)^* \\\\\n&= \\frac{1}{1 - x}\\frac{2x^2}{1 - 2x}\\frac{1}{1 - 3x} \\\\\n&= \\frac{2x^2}{(1 - x)(1 -  2x)(1 - 3x)}.\n\\end{align*}\\]",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Putting Everything Together</span>"
    ]
  },
  {
    "objectID": "regular-languages/putting-it-together.html#trinary-example",
    "href": "regular-languages/putting-it-together.html#trinary-example",
    "title": "21  Putting Everything Together",
    "section": "",
    "text": "Take your regular expression.\nReplace each character like \\(0, 1, 2\\) with \\(x^{f(0)}, x^{f(1)}, x^{f(2)}\\). If we’re weighting by length these should all just be \\(x\\).\nReplace \\(A^*\\) by \\(\\frac{1}{1 - A}\\).\n\n\n\n21.1.1 Getting a formula\nOn it’s face, it’s hard to tell what the taylor series is for this function. So we first ask Sage to give us a partial fraction decomposition.\n\n%display latex\nA = 2x^2 / ((1 - x)*(1 - 2x)*(1 - 3x))\nA.partial_fraction()\n\n\\(\\displaystyle -\\frac{1}{3 \\, x - 1} + \\frac{2}{2 \\, x - 1} - \\frac{1}{x - 1}\\)\n\n\nSage typically puts the \\(x\\)’s first but it’s more useful to us to write this as \\[\n\\frac{1}{1 - 3x} - \\frac{2}{1 - 2x} + \\frac{1}{1 - x}.\n\\]\nWe use the important identity \\(\\frac{1}{1 - ax} = \\sum a^n x^n\\) to convert this to \\[\n\\sum_{n = 0}^\\infty 3^n x^n - 2 \\sum_{n = 0}^{\\infty} 2^n x^n + \\sum_{n = 0}^\\infty x^n = \\sum_{n = 0}^\\infty (3^n - 2 \\cdot 2^n + 1) x^n.\n\\]\nConclusion: there are \\(3^n - 2 \\cdot 2^n + 1\\) trinary strings of length \\(n\\) with at least one \\(1\\) and one \\(2\\).\n\n\n\n\n\n\nNote 21.1\n\n\n\nWe can also obtain this answer by Inclusion/Exclusion. Let \\(X\\) denote the set of all trinary strings of length \\(n\\). Let \\(A\\) be strings with no \\(1\\) and let \\(B\\) be strings with no \\(2\\). Then \\(|X| = 3^n\\) and \\(|A| = |B| = 2^n\\) since each represents strings with two choices of character.\nWe want \\(|X| - |A \\cup B| = |X| - |A| - |B| + |A \\cap B|\\) using the formula we had in Section 5.4. So \\(3^n - 2^n - 2^n + 1\\) which matches what we have using generating functions.\n\n\nWe’re beginning to see how generating functions tie together our material on binomial coefficients, strings, inclusion/exclusion and also recurrence relations.",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Putting Everything Together</span>"
    ]
  },
  {
    "objectID": "regular-languages/putting-it-together.html#sec-fib-put-together",
    "href": "regular-languages/putting-it-together.html#sec-fib-put-together",
    "title": "21  Putting Everything Together",
    "section": "21.2 Fibonacci Example",
    "text": "21.2 Fibonacci Example\nAt the end of Section 20.4, we had the regular expression \\((0 + 10)^*(\\varepsilon + 1)\\). We repeat our method to turn this into a generating function. First, we should point out that \\(\\varepsilon\\) will become \\(x^{f(\\varepsilon)} = x^0 = 1\\). So \\[\n(x + x^2)^*(1 + x) = \\frac{1 + x}{1 - x - x^2}.\n\\]\nPartial fractions don’t help us out here. At least…not easily.\nOn the other hand, we know that the Fibonacci numbers satisfy the recurrence \\(f_n = f_{n - 1} + f_{n - 2}\\). To make the connection clearer, let us write this as\n\\[\nf_n - f_{n - 1} - f_{n - 2}.\n\\]",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Putting Everything Together</span>"
    ]
  },
  {
    "objectID": "regular-languages/putting-it-together.html#more-examples",
    "href": "regular-languages/putting-it-together.html#more-examples",
    "title": "21  Putting Everything Together",
    "section": "21.3 More Examples",
    "text": "21.3 More Examples\nConsider the sequence generated by \\(a_0 = 0, a_1 = 0, a_2 = 1\\) and \\(a_n + 4a_{n - 1} - 2a_{n - 2} + 5a_{n - 3}\\) for \\(n \\ge 3\\).\nWe can compute a generating function \\(\\sum a_n x^n\\) in Sage using the following commands.\n\n\n\n\n\n\nNote\n\n\n\nPer the Sage documentation, the coefficients are given in ascending order (from \\(n - 3\\) to \\(n - 2\\) to \\(n - 1\\)): \\[\na_{n + 3} = -5 a_n + 2 a_{n + 1} - 4 a_{n + 2}.\n\\]\n\n\n\nC = CFiniteSequences(ZZ) # sequences over the integers\nC.from_recurrence([-5, 2, -4], [0, 0, 1]).ogf()\n\n\\(\\displaystyle \\frac{x^{2}}{5x^{3} - 2x^{2} + 4x + 1}\\)\n\n\nThe numerator is hard to predict as it depends on the initial values as well as the recurrence. But pay attention to that denominator: \\[\n1 + 4x - 2x^2 + 5x^3\n\\]\nThese coefficients match our recurrence!",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Putting Everything Together</span>"
    ]
  },
  {
    "objectID": "regular-languages/putting-it-together.html#sec-OGF-to-recursive-formula",
    "href": "regular-languages/putting-it-together.html#sec-OGF-to-recursive-formula",
    "title": "21  Putting Everything Together",
    "section": "21.4 General Result",
    "text": "21.4 General Result\nSuppose a Taylor series \\(\\sum a_n x^n\\) can be written as a rational function \\(P(x)/Q(x)\\) where:\n\n\\(\\deg P &lt; \\deg Q\\)\n\\(Q(x) = c_0 + c_1x + c_2x^2 + \\dots + c_kx^k\\) (degree \\(k\\))\n\nThen the coefficients \\(a_n\\) satisfy the recurrence relation\n\\[\nc_0 a_n + c_1 a_{n - 1} + c_2 a_{n - 2} + \\dots + c_k a_{n - k} = 0, \\text{ for } n \\ge k\n\\]\n(And the reverse holds as well!)\n\n\n\n\n\n\nNote\n\n\n\nThe condition that \\(\\deg P &lt; \\deg Q\\) isn’t crucial to this. It takes care of a few things. First, if \\(\\deg P \\ge \\deg Q\\) we could do long division to simplify.\nSecond, if we have something like \\(x/ (1 - x) = -1 + 1/(1 - x)\\), then the recurrence relation we get from the denominator is \\(a_n = a_{n - 1}\\) but if we write down this Taylor series, the coefficients are \\(0, 1, 1, 1, 1, \\dots\\). So the recurrence relation \\(a_n = a_{n - 1}\\) only holds if \\(n \\ge 2\\).\nThe big takeaway here is: making \\(\\deg P \\ge \\deg Q\\) alters the initial terms and the recurrence relation takes longer to kick in.\n\n\n\nProof. Let \\(A = \\sum a_n x^n = P(x) / Q(x)\\). Multiplying both sides by \\(Q(x)\\) we should find that \\(AQ = P\\) (a polynomial). So \\[\\begin{align*}\nAQ &= (c_0 + c_1x + \\dots + c_kx^k) \\sum a_n x^n \\\\\n&= c_0 \\sum a_n x^n + c_1 \\sum a_nx^{n + 1} + \\dots + c_k \\sum a_n x^{n + k} \\\\\n&= c_0 \\sum a_n x^n + c_1 \\sum a_{n - 1}x^n + \\dots + c_k \\sum a_{n - k} x^n.\n\\end{align*}\\]\nNow this is supposed to be a polynomial. And it is, if and only if the coefficients are \\(0\\) for \\(n\\) bigger than \\(\\deg P\\) and in particular if \\(n \\ge k = \\deg Q\\). So for \\(n \\ge k\\), we have \\[\nc_0 a_n + c_1 a_{n - 1} + \\dots + c_k a_{n - k}.\n\\]\nAnd the steps here are reversible: if we satisfy this recurrence then \\(AQ\\) is a polynomial of degree less than \\(k\\).",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Putting Everything Together</span>"
    ]
  },
  {
    "objectID": "regular-languages/putting-it-together.html#epilogue",
    "href": "regular-languages/putting-it-together.html#epilogue",
    "title": "21  Putting Everything Together",
    "section": "21.5 Epilogue",
    "text": "21.5 Epilogue\nWhen our generating function comes apart nicely into partial fractions, we can use the identity \\(\\frac{1}{1 - ax} = \\sum a^n x^n\\) to extract the coefficient of \\(a^n\\). More generally, we can handle generating functions like \\(1 / (1 - ax)^k\\) using the formulas of Section 16.4.\nFor something like \\(x / (1 - x - x^2)\\), partial fractions can be used to obtain \\[\n\\frac{x}{1 - x - x^2} = \\frac1{\\sqrt5} \\left( \\frac{1}{1 - \\phi x} - \\frac{1}{1 - \\psi x} \\right); \\text{ where } \\phi, \\psi = \\frac{1 \\pm \\sqrt 5}{2}.\n\\]\nWith the resulting formula \\[\nf_n = \\frac{1}{\\sqrt 5}(\\phi^n -  \\psi^n).\n\\] Known as Binet’s formula which we saw a version of in Section 14.3.1. This formula is super cool but computationally leaves a lot to be desired as multiplying large decimal numbers together can be quite expensive.\nThe fastest way to compute the Fibonacci sequence comes right from the recurrence definition. With a little bit of linear algebra, we can turn that linear recurrence into \\[\n\\begin{pmatrix}\n0 & 1 \\\\\n1 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\nf_n \\\\\nf_{n + 1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 f_n + f_{n + 1} \\\\\nf_n + f_{n + 1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf_{n + 1} \\\\\nf_{n + 2}\n\\end{pmatrix}.\n\\]\nSo the Fibonacci numbers and in fact, all of these linear recurrence relations, can be computed via matrix multiplication. This has the immediate advantage that we can use the identity \\(A^{2n} = (A^n)^2\\) to cut down our number of steps quite significantly. I.e. we have an algorithm where if \\(n\\) has \\(k\\) bits in binary, then the algorithm takes \\(\\mathcal O(k) = \\mathcal O(\\log_2 n)\\) matrix multiplications.\n\n\n\n\n\n\nTip\n\n\n\nThe Sage commands for this look like\n\nC = CFiniteSequences(ZZ)\nFib = C.from_recurrence([1, 1], [0, 1])\nFib.closed_form()\n\n\\(\\displaystyle \\sqrt{\\frac{1}{5}} {\\left(\\frac{1}{2} \\, \\sqrt{5} + \\frac{1}{2}\\right)}^{n} - \\sqrt{\\frac{1}{5}} {\\left(-\\frac{1}{2} \\, \\sqrt{5} + \\frac{1}{2}\\right)}^{n}\\)",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Putting Everything Together</span>"
    ]
  },
  {
    "objectID": "regular-languages/transfer-matrix.html",
    "href": "regular-languages/transfer-matrix.html",
    "title": "22  Transfer Matrix Method",
    "section": "",
    "text": "22.1 Example\nLet \\(D\\) be a directed graph on the vertices \\(1, \\dots, n\\). The adjacency matrix of \\(D\\) is the matrix \\(A = A(D)\\) where \\[\nA_{ij} = \\begin{cases}\n1 & \\text{if } i \\to j \\text{ is a directed edge}, \\\\\n0 & \\text{otherwise}\n\\end{cases}\n\\]\nThese adjacency matrices allow for loop edges \\(i \\to i\\) and can be made to allow for parallel edges if we let \\(A_{ij}\\) be the number of parallel edges from \\(i \\to j\\).\nConsider the graph\n1\n\n1\n\n\n\n2\n\n2\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n\n3\n\n\n\n1-&gt;3\n\n\n\n\n\n2-&gt;2\n\n\n\n\n\n3-&gt;1\n\n\n\n\n\n3-&gt;2\n\n\n\n\n\n\n\n\nFigure 22.1: A digraph on 1,2,3 with edges 12, 13, 22, 31, 32\nThe adjacency matrix of this digraph is \\[\nA ={}\n\\begin{array}{c c}\n& \\begin{array}{@{} c c c @{}} 1 & 2 & 3 \\end{array} \\\\\n\\begin{array}{c} 1 \\\\ 2 \\\\ 3 \\end{array} \\hspace{-1em} &\n\\begin{pmatrix}\n0 & 1 & 1 \\\\\n0 & 1 & 0 \\\\\n1 & 1 & 0\n\\end{pmatrix} \\\\\n\\mbox{}\n\\end{array}\n\\tag{22.1}\\]\nFor instance, row \\(1\\) says that vertex \\(1\\) has edges \\(1 \\to 2\\) and \\(1 \\to 3\\).",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Transfer Matrix Method</span>"
    ]
  },
  {
    "objectID": "regular-languages/transfer-matrix.html#matrix-multiplication",
    "href": "regular-languages/transfer-matrix.html#matrix-multiplication",
    "title": "22  Transfer Matrix Method",
    "section": "22.2 Matrix Multiplication",
    "text": "22.2 Matrix Multiplication\nIn linear algebra, we define the product of two matrices \\(A\\) and \\(B\\) by \\[\n(AB)_{ij} = \\sum_t A_{it} B_{tj}.\n\\]\nVisually, this means we take the \\(i\\)-th row of \\(A\\) and take the dot product with the \\(j\\)-th row of \\(B\\). For instance, if \\(A\\) is the adjacency matrix in Equation 22.1, then \\[\nA_{12} = \\begin{pmatrix} 0 & 1 & 1 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = 0 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 = 2.\n\\]\nThis product has a combinatorial meaning: \\[\n(A^2)_{ij} = \\sum_t A_{it}A_{tj} = \\sum_t \\begin{cases}\n1 & \\text{if } i \\to t \\to j \\text{ are edges}, \\\\\n0 & \\text{else}.\n\\end{cases}\n\\]\nIn other words: \\(A^2\\) gives the number of walks of length \\(2\\).\n\nTheorem 22.1 If \\(A\\) is the adjacency matrix for some digraph \\(D\\), then \\((A^n)_{ij}\\) is the number of walks of length \\(n\\) from \\(i\\) to \\(j\\).\n\n\nProof. We prove this by induction. First, the base case: if \\(n = 1\\) then \\((A^1)_{ij} = A_{ij}\\) is by definition the number of walks (single edges) from \\(i\\) to \\(j\\).\nFor the inductive step, we assume that (for every \\(i\\) and \\(j\\)) \\((A^{n - 1})_{ij}\\) counts the number of walks from \\(i\\) to \\(j\\) of length \\(n - 1\\). Then \\[\n(A^n)_{ij} = (A^{n - 1}A)_{ij} = \\sum_t (A^{n-1})_{it}A_{tj}.\n\\] Here, the first factor, \\((A^{n-1})_{it}\\) counts the number of walks from \\(i\\) to \\(t\\) of length \\(n - 1\\) and \\(A_{tj}\\) is the number of edges from \\(t\\) to \\(j\\). So the whole term \\((A^{n-1})_{it}A_{tj}\\) counts the number of walks from \\(i\\) to \\(t\\) to \\(j\\). So this is every walk of length \\(n\\) from \\(i\\) to \\(j\\).\n\n\n22.2.1 Example\nFor the digraph in Figure 22.1, how many walks are there of length \\(3\\) from vertex \\(1\\) to vertex \\(2\\)? We can do \\(1,2,2,2\\); or \\(1,3,2,2\\); or \\(1,3,1,2\\). So there are \\(3\\) walks of length \\(3\\). Therefore, we expect that \\(A^3\\) will have a \\(3\\) in row \\(1\\), column \\(2\\). Let’s use SageMath to check this.\n\n%display latex\nA = Matrix([[0, 1, 1], [0, 1, 0], [1, 1, 0]])\nA^3\n\n\\(\\displaystyle \\left(\\begin{array}{rrr}\n0 & 3 & 1 \\\\\n0 & 1 & 0 \\\\\n1 & 3 & 0\n\\end{array}\\right)\\)\n\n\nExamples of other things this matrix tells us: there are \\(0\\) walks from \\(1\\) to \\(1\\) of length \\(3\\); there is only \\(1\\) walk of length \\(3\\) from \\(1\\) to \\(3\\), namely \\(1,3,1,3\\).",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Transfer Matrix Method</span>"
    ]
  },
  {
    "objectID": "regular-languages/transfer-matrix.html#sec-transfer-ogf",
    "href": "regular-languages/transfer-matrix.html#sec-transfer-ogf",
    "title": "22  Transfer Matrix Method",
    "section": "22.3 Generating Functions",
    "text": "22.3 Generating Functions\nRecall that when we started with generating functions, a monomial like \\(ax^n\\) meant “\\(a\\) objects of length or size \\(n\\).” So if we do \\(A^nx^n\\) then the entries will represent “\\((A^n)_{ij}\\) walks of length \\(n\\).” Then the generating function for this is \\[\\begin{align*}\nM &= A^0x^0 + A^1x^1 + A^2x^2 + A^3x^3 + \\cdots \\\\\n&= I + Ax + A^2x^2 + A^3x^3 + \\cdots \\\\\n&= (I - Ax)^{-1}\n\\end{align*}\\]\nWhere we use a similar formula as our geometric series, \\(\\frac{1}{1-ax}\\), except \\(a\\) is now a matrix.\nFor the digraph in Figure 22.1, this generating function is\n\nM = (identity_matrix(3) - A*x)^-1\nM.simplify_rational()\n\n\\(\\displaystyle \\left(\\begin{array}{rrr}\n-\\frac{1}{x^{2} - 1} & \\frac{x}{x^{2} - 2 \\, x + 1} & -\\frac{x}{x^{2} - 1} \\\\\n0 & -\\frac{1}{x - 1} & 0 \\\\\n-\\frac{x}{x^{2} - 1} & \\frac{x}{x^{2} - 2 \\, x + 1} & -\\frac{1}{x^{2} - 1}\n\\end{array}\\right)\\)\n\n\n\nTheorem 22.2 Each entry \\(M_{ij}\\) of this matrix is the generating function for the number of walks from vertex \\(i\\) to vertex \\(j\\).\n\nFor instance, the generating function for walks from vertex \\(1\\) to vertex \\(3\\) is \\[\n\\frac{x}{1 - x^2} = x + x^3 + x^5 + x^7 + \\cdots.\n\\] This agrees with what we can see from the diagram: there is exactly one walk of length \\(n\\) for any odd number \\(n\\) and none of even length.\nOf course, the true utility of this is when we can’t do the calculation in our heads of the number of walks. For instance, the number of walks from vertex \\(1\\) to vertex \\(2\\) of length \\(n\\) is given by the generating function \\[\n\\frac{x}{1 - 2x + x^2} = \\frac{x}{(1 - x)^2} = \\sum_{n = 0}^\\infty nx^n\n\\] (using the formula from Section 16.4). So there are \\(n\\) walks of length \\(n\\).",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Transfer Matrix Method</span>"
    ]
  },
  {
    "objectID": "regular-languages/transfer-matrix.html#fibonacci",
    "href": "regular-languages/transfer-matrix.html#fibonacci",
    "title": "22  Transfer Matrix Method",
    "section": "22.4 Fibonacci",
    "text": "22.4 Fibonacci\nWe can use this method to simplify a lot of the work we had to do with state elimination. Have a look at our Fibonacci automaton again, simplified down to \\(2\\) states.\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    0 --&gt; 0 : 0\n    0 --&gt; 1 : 1\n    1 --&gt; 0 : 0\n\n\n\n\nFigure 22.2: FSA for binary strings with no 11, no sink state\n\n\n\n\n\nA valid string is a walk from vertex \\(0\\) to either vertex \\(0\\) or vertex \\(1\\) (depending on the last bit of the string). So we want \\(M_{00} + M_{01}\\) for the number of walks from vertex \\(0\\) to vertex \\(0\\) plus from vertex \\(0\\) to vertex \\(1\\).\nHere’s how to accomplish that in SageMath. We start with the adjacency matrix\n\\[\nA = \\begin{pmatrix}\n1 & 1 \\\\\n1 & 0\n\\end{pmatrix}\n\\]\nThen compute \\(M = (I - A)^{-1}\\)\n\nA = Matrix([[1, 1], [1, 0]])\nI = identity_matrix(2)\nM = (I - A*x)^-1\nOGF = M[0][0] + M[0][1]\nOGF.simplify_rational()\n\n\\(\\displaystyle -\\frac{x + 1}{x^{2} + x - 1}\\)\n\n\nAnd this matches our answer in Section 21.2.",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Transfer Matrix Method</span>"
    ]
  },
  {
    "objectID": "regular-languages/transfer-matrix.html#recurrence-relations",
    "href": "regular-languages/transfer-matrix.html#recurrence-relations",
    "title": "22  Transfer Matrix Method",
    "section": "22.5 Recurrence Relations",
    "text": "22.5 Recurrence Relations\nWith all this matrix algebra, the results we get can get pretty gnarly. Sometimes it’s enough to get a recurrence relation to describe our answer. By Section 21.4, we know that the recurrence is given by the denominator.\nWe will use now a theorem from linear algebra.\n\nTheorem 22.3 The inverse of a matrix \\(A\\) is given by \\[\nA^{-1} = \\frac{1}{\\det A} \\operatorname{Adj}(A)\n\\] where the adjugate matrix \\(\\operatorname{Adj}(A)\\) has entries given by determinants of \\(A\\) deleting one row and one column.\n\nWhat’s important to us here is that the denominator is \\(\\det A\\). So the denominator of our generating functions is \\[\n\\det(I - Ax)\n\\]\nThis is related to the characteristic polynomial but with the coefficients reversed.\n\n22.5.1 Example\nFor our Fibonacci FSA in Figure 22.2, the denominator is\n\ndet(I - A*x)\n\n\\(\\displaystyle -x^{2} - x + 1\\)\n\n\nThis tells us the recurrence relation is \\[\n\\begin{array}{cccc}\n1 & -1 x & -1 x^2 & \\\\\n\\downarrow & \\downarrow & \\downarrow & \\\\\na_n & - a_{n - 1} & - a_{n - 2} & = 0\n\\end{array}\n\\]\n\n\n\n\n\n\nNote\n\n\n\nIn Section 22.3, we saw that some of the denominators were \\(1 - x^2 = (1 - x)(1 + x)\\) and some were \\(1 - x\\) and some were \\((1 - x)^2\\). The denominator we calculate using \\(\\det(I - Ax)\\) is \\((1 - x)^2(1 + x) = 1 - x - x^2 + x^3\\) leading to the recurrence \\(a_n - a_{n - 1} - a_{n - 2} + a_{n - 3}\\).\nAll of the quantities will satisfy the longer recurrence but they also individually satisfy a shorter recurrence which may be different from their siblings.",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Transfer Matrix Method</span>"
    ]
  },
  {
    "objectID": "regular-languages/regular-languages-exercises.html",
    "href": "regular-languages/regular-languages-exercises.html",
    "title": "23  Exercises",
    "section": "",
    "text": "For each of the automata below, eliminate the state “E” by:\n\nfirst identify all the arrows pointing into “E” and out of “E”\nreplace each path \\(A \\xrightarrow{u} E \\xrightarrow{v} B\\) by \\(A \\xrightarrow{ul^*v} B\\) where \\(l\\) is the loop at “E”.\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; E\n    E --&gt; A : 0\n    E --&gt; B : 1\n    A --&gt; A : 0\n    B --&gt; A : 1\n\n\n\n\nFigure 23.1: FSA for exercise 1\n\n\n\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; A\n    A --&gt; A : 0\n    A --&gt; E : 1\n    E --&gt; E : 0\n    E --&gt; B : 1\n    B --&gt; E : 1\n    B --&gt; [*]\n\n\n\n\nFigure 23.2: FSA for exercise 1\n\n\n\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; A\n    A --&gt; E : 0\n    B --&gt; E : 0\n    A --&gt; B : 1\n    E --&gt; E : 1\n    E --&gt; A : 0\n\n\n\n\nFigure 23.3: FSA for exercise 1\n\n\n\n\n\n\nWrite the described language using \\(+, \\cdot\\) (concatenation) and \\(^*\\) (Kleene star or plus)\n\n\\(\\{\\varepsilon, 0, 1, 11, 111, 1111, \\cdots\\}\\)\nStrings of \\(0\\)s with at least two \\(0\\)s\nStrings of \\(0\\)s with an even number of \\(0\\)s\nStrings of \\(0\\)s with an odd number of \\(0\\)s\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\n\nHow does this compare to \\(\\{\\varepsilon, 1, 11, 111, 1111, \\dots\\} = 1^*\\)?\nSet the two \\(0\\)s aside first (compare to \\(a^+ = aa^*\\))\nThink in terms of repeating \\(00\\)\nCombine ideas from b. and c.\n\n\n\n\n\nConsider the language \\(L = 0^*(11)^*\\).\n\nList all words in \\(L\\) of length \\(\\le 6\\).\nLet \\(a_n\\) be the number of words in \\(L\\) of length \\(n\\). Using part a, guess a formula for \\(a_n\\) (which may depend on whether \\(n\\) is even or odd).\nCan you prove your formula?\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\nIn words: \\(L\\) describes languages with some number of \\(0\\)s followed by an even number of \\(1\\)s. So for instance, if \\(n = 9\\), the possible number of \\(1\\)s is \\(0, 2, 4, 6, 8\\) and there would be \\(5\\) possible strings. The formula should look something like \\(n/2\\) or \\((n + 1)/2\\).\n\n\n\n\nConsider a tiling problem where we tile a \\(2 \\times n\\) grid using horizontal or vertical dominos (\\(1 \\times 2\\) or \\(2 \\times 1\\)) or a \\(2 \\times 2\\) square. Let \\(\\Sigma = \\{V, H, S\\}\\) where \\(V\\) represents a vertical domino, \\(H\\) represents a horizontal domino, and \\(S\\) represents a square. A tiling can be described by the language \\(L = \\Sigma^*\\).\n\nLet \\(f\\) be the weight function describing the width. So \\(f(V) = 1, f(H) = f(S) = 2\\). What is the generating function for \\(\\Sigma\\)?\nWhat is the generating function for \\(L = \\Sigma^*\\)?\nUsing SageMath’s Taylor series method, compute the number of such tilings of a \\(2 \\times 10\\) grid. Note: you have to write 2*x rather than 2x in SageMath.\nUsing our techniques from recursion, what is a recursive formula for the number of tilings \\(t_n\\)? Compare this to the denominator of your OGF like in Section 21.4.\n\n\n\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\nThe generating function of \\(\\Sigma\\) is \\[\n\\Phi_\\Sigma = \\sum_{w \\in \\Sigma} x^{f(w)} = x^{f(V)} + x^{f(H)} + x^{f(S)}.\n\\] For b. use Theorem 19.1.\nFor d. use the fact that a tiling of length \\(n\\) is either: * a tiling of length \\(n - 1\\) followed by a vertical domino, * a tiling of length \\(n - 2\\) followed by either a pair of horizontal dominoes or a square (so \\(2\\) options).\n\n\n\n\nDraw a finite automata for:\n\nthe language \\(0^*(11)^*\\)\nthe language \\((0 + 11)^*\\)\n\n\nThe automata in these notes were drawn using the Mermaid Javascript library. You may wish to copy the following code to mermaid.live and modify it to create the FSA you need.\nstateDiagram-v2\n    direction LR\n    classDef accept stroke-width:5px\n    [*] --&gt; 0\n    0 --&gt; 0 : 0\n    0 --&gt; 1 : 1\n    1 --&gt; 11 : 1\n    11 --&gt; 11 : 1\n\n    class 0, 11 accept\n\n\n\n\n\n\nTipHint\n\n\n\n\n\nThe FSA for part a should require only slight modification of the sample Mermaid diagram. Likewise, part b should require only slight modification from part a.\n\n\n\n\nTake the FSA from the previous question and perform state elimination to check if you recover the regular expression you started with. Remember to add in a termination state before you start eliminating.\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\nUse the \\(ab^*c\\) formula described in Section 20.3.1 on each path \\(A \\to S \\to B\\) to eliminate \\(S\\).\n\n\n\n\nIn Example 8.18 of Keller and Trotter’s book, they show using exponential generating functions that the number of ternary strings with an even number of \\(0\\)s is \\((3^n + 1)/2\\). In this exercise, we will get this answer using ordinary generating functions.\n\nDraw a FSA for this language (you can do it in two states, not including the start and end).\nPerform state elimination to obtain a regular expression.\nConvert that regular expression to an OGF.\nUsing SageMath, find a partial fraction decomposition for the OGF.\nVerify that the Taylor series is \\(\\sum \\frac{3^n + 1}{2} x^n\\).\n\n\n\n\n\n\n\n\n\n\n\nTipHint\n\n\n\n\n\n\nThe start state will represent an even number of \\(0\\)s seen so far and another state will represent an odd number.\nEliminate the odd state using the elimination rule: in(loop)*out.\nReplace \\(0, 1, 2\\) by \\(x^1\\) since each of those characters has length \\(1\\).\nDon’t forget to use 2*x rather than 2x.\nUse the formula \\(\\frac{a}{1 - r} = \\sum ar^n\\).\n\n\n\n\n\n\nSolutions\n\n\n\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; E\n    E --&gt; A : 0\n    E --&gt; B : 1\n\n\n\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; A : 0\n    [*] --&gt; B : 1\n    A --&gt; A : 0\n    B --&gt; A : 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    A --&gt; E : 1\n    E --&gt; E : 0\n    E --&gt; Bout : 1\n    Bin --&gt; E : 1\n\n\n\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; A\n    A --&gt; A : 0\n    A --&gt; B : 10*1\n    B --&gt; B : 10*1\n    B --&gt; [*]\n\n\n\n\n\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    Ain --&gt; E : 0\n    B --&gt; E : 0\n    E --&gt; E : 1\n    E --&gt; Aout : 0\n\n\n\n\n\n\n\n\n\n\n\nstateDiagram\n    direction LR\n\n    [*] --&gt; A\n    A --&gt; A : 01*0\n    B --&gt; A : 01*0\n    A --&gt; B : 1\n\n\n\n\n\n\n\n\n\n\n\\(0 + 1^*\\)\n\\(000^*\\) or \\(00^+\\)\n\\((00)^*\\)\n\\(0(00)^*\\)",
    "crumbs": [
      "Regular Languages",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Exercises</span>"
    ]
  }
]