{
  "hash": "4734f10b5f1b2a962a4b617ebea6a036",
  "result": {
    "engine": "jupyter",
    "markdown": "# Regular Languages\n\nAt this point we've seen numerous examples where a language is composed of a sequence of blocks.\n\n* A binary string is a sequence of $0$s and $1$s\n* A Dyck path is a sequence of smaller paths, shifted properly\n* A tiling of a $2 \\times n$ grid using dominoes is a sequence of vertical dominoes or pairs of horizontal dominoes\n* Equivalently: we looked at sequences of $1$s and $2$s which sum to $n$; both give the Fibonacci numbers\n* Binary strings with no $11$---also counted by the Fibonacci numbers---can be broken into sequences of blocks although the blocks are more complex than the previous example\n\n## Kleene Star\n\nLet $L$ be a language that does not contain the empty string (for reasons of unique representation). The language which repeats $L$ in a sequence is called the Kleene star of $L$, denoted $L^*$. An element of $L^*$ is some finite sequence\n$$\nu_1 u_2 \\cdots u_k, \\text{ where } u_i \\in L.\n$$\nAnother name for such a sequence of length $k$ is $L^k$ (concatenating $k$ strings from $L$). Thus,\n$$\nL^* = L^0 \\cup L^1 \\cup L^2 \\cup L^3 \\cup \\cdots.\n$$\nIt's also common notation to write these unions with a $+$ sign to mean \"or\" (with a heavy implication that we want this to be disjoint). Also note that $L^0 = \\{\\varepsilon\\}$ because concatenating $0$ strings yields an empty string. So we have\n$$\nL^* = \\varepsilon + L + L^2 + L^3 + \\cdots.\n$$\n\n### Kleene Plus\n\nA related construction considers only the sequences of positive length. This is called the Kleene plus operator and it is defined by\n$$\nL^+ = L + L^2 + L^3 + \\cdots.\n$$\n\n## Relation to Generating Functions\n@thm-ogf-addition and @thm-ogf-multiplication imply the following theorem.\n\n::: {#thm-ogf-kleene}\n### Kleene star and plus\nProvided the sets $L^0, L^1, L^2, \\dots$ are *disjoint*,\n\\begin{align*}\n\\Phi_{L^*} &= \\Phi_{L^0} + \\Phi_{L^1} + \\Phi_{L^2} + \\Phi_{L^3} + \\cdots \\\\\n&= \\Phi_L^0 + \\Phi_L^1 + \\Phi_L^2 + \\Phi_L^3 + \\cdots \\\\\n&= \\frac{1}{1 - \\Phi_L}.\n\\end{align*}\nSimilarly,\n\\begin{align*}\n\\Phi_{L^+} &= \\Phi_L^1 + \\Phi_L^2 + \\Phi_L^3 + \\cdots \\\\\n&= \\frac{\\Phi_L}{1 - \\Phi_L}.\n\\end{align*}\n:::\n\n## Examples {#sec-regular-language-examples}\nConsider our sequences of $1$s and $2$s which gave us the Fibonacci sequence. Here, unlike many previous examples, we don't want to weight sequences by length but rather by sum (we're looking for sequences whose sum is $n$ not whose length is $n$). So let $f$ denote the sum of a sequence, e.g. $f(122) = 1 + 2 + 2 = 5$.\n\nLet $L = \\{1, 2\\}$. Then $L^*$ represents all sequences of $1$s and $2$s. By theorem @thm-ogf-kleene, we have\n$$\n\\Phi_{L^*} = \\frac{1}{1 - \\Phi_L} = \\frac{1}{1 - (x^{f(1)} + x^{f(2)})} = \\frac{1}{1 - x - x^2}.\n$$ {#eq-12-fib-ogf}\n\nWe know that the number of these sequences which sum to $n$ is counted by the Fibonacci sequence, so like we stated @sec-convergence, we have\n\n\n\n::: {#c49f18d9 .cell execution_count=2}\n``` {.sage .cell-code}\ntaylor(1/(1 - x - x^2), x, 0, 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<html>\\(\\displaystyle 89 \\, x^{10} + 55 \\, x^{9} + 34 \\, x^{8} + 21 \\, x^{7} + 13 \\, x^{6} + 8 \\, x^{5} + 5 \\, x^{4} + 3 \\, x^{3} + 2 \\, x^{2} + x + 1\\)</html>\n```\n:::\n:::\n\n\n### Avoiding '11'\nIf we want to avoid $11$ we need to make sure that everyone $1$ has at least one $0$ next to it. We can do this with the language $0^+1$ which guarantees a zero on the left. Taking sequences of these, we get $(0^+1)^*$.\n\nWe're getting close to the description. We also need to allow a potential initial $1$ in case because that's the place in the string which might have $0$s only on the right. So $(\\varepsilon + 1)(0^+1)^*$. Lastly, we can have as many zeros as we want after the last $1$ so $L = (\\varepsilon + 1)(0^+1)^*0^*$.\n\nHere we're weighting by length again, so\n\n* $\\Phi_{\\varepsilon + 1} = x^0 + x^1$\n* $\\Phi_{0^+1} = \\frac{x}{1 - x} \\cdot x = \\frac{x^2}{1 - x}$\n* $\\Phi_{(0^+1)^*} = \\frac{1}{1 - \\frac{x^2}{1 - x}}$\n* $\\Phi_{0^*} = \\frac{1}{1 - x}$\n\nPutting that all together, we have\n$$\n\\Phi_L = (1 + x) \\cdot \\frac{1}{1 - \\frac{x^2}{1 - x}} \\cdot \\frac{1}{1 - x} = \\frac{1 + x}{1 - x - x^2}.\n$$\n\nThis is similar to @eq-12-fib-ogf but the numerator shifts the sequence over a step:\n\n::: {#6ba32f7e .cell execution_count=3}\n``` {.sage .cell-code}\ntaylor((1 + x)/(1 - x - x^2), x, 0, 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<html>\\(\\displaystyle 144 \\, x^{10} + 89 \\, x^{9} + 55 \\, x^{8} + 34 \\, x^{7} + 21 \\, x^{6} + 13 \\, x^{5} + 8 \\, x^{4} + 5 \\, x^{3} + 3 \\, x^{2} + 2 \\, x + 1\\)</html>\n```\n:::\n:::\n\n\n## Even number of 1s\nHeuristically, half of all binary strings should have an even number of $1$s and half should have an odd number. We'll prove this using generating functions.\n\nFor a start, the language of binary strings can be written as $(0 + 1)^*$ (sequences of $0$s or $1$s). If we want to guarantee that every $1$ is partnered with a second $1$ later on, then we can modify this to $L = (0 + 10^*1)^*$. Now we compute\n$$\n\\Phi_{10^*1} = x \\cdot \\frac{1}{1 - x} \\cdot x = \\frac{x^2}{1 - x}.\n$$\nSo therefore,\n\\begin{align*}\n\\Phi_L &= \\frac{1}{1 - (x + \\frac{x^2}{1 - x})} \\\\\n&= \\frac{1 - x}{(1 - x) - x(1 - x) - x^2} \\\\\n&= \\frac{1 - x}{1 - 2x} \\\\\n&= \\frac{1}{1 - 2x} - \\frac{x}{1 - 2x} \\\\\n&= \\sum_{n = 0}^\\infty 2^n x^n - \\sum_{n = 0}^\\infty 2^{n} x^{n + 1} \\\\\n&= \\sum_{n = 0}^\\infty 2^n x^n - \\sum_{n = 1}^\\infty 2^{n - 1} x^{n}.\n\\end{align*}\n\nAnd that means that the number of such strings is\n$$\n\\begin{cases}\n2^n - 2^{n - 1} = 2^{n - 1} & \\text{if } n \\ge 1 \\\\\n1 & \\text{if } n = 0\n\\end{cases}.\n$$\n\n## Regular Languages\nWe describe **regular languages** inductively:\n\n* a finite language is regular\n* if $L, L'$ are regular then so is $L + L'$\n* if $L, L'$ are regular then so is $LL'$\n* if $L, L'$ are regular then so are $L^*$ and $L^+$\n\nThat is, a regular language is everything you can create out of a finite description using unions, concatenations, Kleene stars and pluses, and letters from the alphabet.\n\nSuch a description using these operations is known as a **regular expression**. This concept is closely related to regular expressions in computer programming although computer programming includes many more operations such as the `?` operator where $L? = \\varepsilon + L$.\n\n::: {.callout-note}\nSome regular expression operators in computer programming allow one to create languages which are not regular. For instance, back-references allow one to ask whether a previous part of the string has been repeated. So computer programming regular expressions exceeds what formal language regular expressions can describe. [See Wikipedia for more info.](https://en.wikipedia.org/wiki/Regular_expression#Patterns_for_non-regular_languages)\n:::\n\n",
    "supporting": [
      "regular-languages_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}